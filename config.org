* Emacs config

  This is my emcas configuration written in ORG which is tangled by org babel
  during startup.

  Its evil/ivy based and keybindings, package selection and setup is heavily
  inspired by spacemacs but rather than making it ultra modular I've tried to
  keep it as simple as possible focusing on making it easy to debug and quick to
  navigate when adding or disabling stuff on the fly

  The initial sections contain global configuration, package configuration and
  my own set of custom commands.

  The later sections are structured around mode and keymap hierarchies so that
  configuration defined in a section also applies for all subsection. The
  sections are further divided into smaller blocks to make it possible to
  disable packages or configuration while still keeping it bundled with the mode
  it appleies to.

* initialize package
 We start by adding package repos and load paths and initialize package
#+BEGIN_SRC emacs-lisp :tangle yes
     (require 'package)
     (add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/") t)
     (add-to-list 'package-archives '("gnu" . "https://elpa.gnu.org/packages/") t)
     (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/") t)
     (let ((default-directory (concat user-emacs-directory "submodules/")))
       (normal-top-level-add-subdirs-to-load-path))
     (add-to-list 'load-path (concat user-emacs-directory "local/"))
     (package-initialize)
#+END_SRC
    Ensure some dependencies are installed. The packages use-package and bind-map are installed, these will be used to
    manage packages and keybindings throughout the config.
#+BEGIN_SRC emacs-lisp :tangle yes
  (dolist (package '(dash use-package bind-map)) nil
    (unless (package-installed-p package)
      (package-refresh-contents)
      (package-install package)))
  (require 'use-package)
(require 'bind-map)
   #+END_SRC
* global
** funcs
*** from spacemacs
    This is a set of functions and commands copied from spacemacs
    mainly used for window and buffer management that i found it hard
    to live .

    this is the original copyright notice
    #+BEGIN_SRC emacs-lisp :tangle yes
      ;;; spacemacs-functions.el --- Library of selected functions taken from spacemacs
      ;;
      ;; Copyright (c) 2012-2017 Sylvain Benner & Contributors
      ;;
      ;; Author: Sylvain Benner <sylvain.benner@gmail.com>
      ;; URL: https://github.com/syl20bnr/spacemacs
      ;;
      ;; This file is not part of GNU Emacs.
      ;;
      ;;; License: GPLv3

      ;; our own implementation of kill-this-buffer from menu-bar.el
    #+END_SRC

    #+BEGIN_SRC emacs-lisp :tangle yes
      (defun spacemacs/kill-this-buffer (&optional arg)
       	"Kill the current buffer.
      If the universal prefix argument is used then kill also the window."
       	(interactive "P")
       	(if (window-minibuffer-p)
            (abort-recursive-edit)
          (if (equal '(4) arg)
              (kill-buffer-and-window)
            (kill-buffer))))
    #+end_src

    #+begin_src emacs-lisp :tangle yes
      (defun spacemacs/ace-kill-this-buffer (&optional arg)
       	"Ace kill visible buffer in a window.
      If the universal prefix argument is used then kill also the window."
       	(interactive "P")
       	(require 'ace-window)
       	(let (golden-ratio-mode)
          (aw-select
           " Ace - Kill buffer in Window"
           (lambda (window)
             (with-selected-window window
               (spacemacs/kill-this-buffer arg))))))
    #+end_src

    #+begin_src emacs-lisp :tangle yes
      ;; found at http://emacswiki.org/emacs/KillingBuffers
      (defun spacemacs/kill-other-buffers (&optional arg)
       	"Kill all other buffers.
      If the universal prefix argument is used then will the windows too."
       	(interactive "P")
       	(when (yes-or-no-p (format "Killing all buffers except \"%s\"? "
                                   (buffer-name)))
          (mapc 'kill-buffer (delq (current-buffer) (buffer-list)))
          (when (equal '(4) arg) (delete-other-windows))
          (message "Buffers deleted!")))
    #+end_src

    #+begin_src emacs-lisp :tangle yes
      ;; http://camdez.com/blog/2013/11/14/emacs-show-buffer-file-name/
      (defun spacemacs/show-and-copy-buffer-filename ()
       	"Show and copy the full path to the current file in the minibuffer."
       	(interactive)
       	;; list-buffers-directory is the variable set in dired buffers
       	(let ((file-name (or (buffer-file-name) list-buffers-directory)))
          (if file-name
              (message (kill-new file-name))
            (error "Buffer not visiting a file"))))
    #+end_src

    #+begin_src emacs-lisp :tangle yes
      (defun spacemacs/new-empty-buffer ()
       	"Create a new buffer called untitled(<n>)"
       	(interactive)
       	(let ((newbuf (generate-new-buffer-name "untitled")))
          (switch-to-buffer newbuf)))
    #+end_src

    #+begin_src emacs-lisp :tangle yes
      (defun spacemacs/safe-revert-buffer ()
       	"Prompt before reverting the file."
       	(interactive)
       	(revert-buffer nil nil))
    #+end_src

    #+begin_src emacs-lisp :tangle yes
      (defun spacemacs/safe-erase-buffer ()
       	"Prompt before erasing the content of the file."
       	(interactive)
       	(if (y-or-n-p (format "Erase content of buffer %s ? " (current-buffer)))
            (erase-buffer)))
    #+end_src

    #+begin_src emacs-lisp :tangle yes
      ;; http://stackoverflow.com/a/10216338/4869
      (defun spacemacs/copy-whole-buffer-to-clipboard ()
       	"Copy entire buffer to clipboard"
       	(interactive)
       	(clipboard-kill-ring-save (point-min) (point-max)))
    #+end_src

    #+begin_src emacs-lisp :tangle yes
      (defun spacemacs/copy-clipboard-to-whole-buffer ()
       	"Copy clipboard and replace buffer"
       	(interactive)
       	(delete-region (point-min) (point-max))
       	(clipboard-yank)
       	(deactivate-mark))
    #+end_src

    #+begin_src emacs-lisp :tangle yes
      (defun spacemacs/switch-to-scratch-buffer ()
       	"Switch to the `*scratch*' buffer. Create it first if needed."
       	(interactive)
       	(let ((exists (get-buffer "*scratch*")))
          (switch-to-buffer (get-buffer-create "*scratch*"))
          (when (and (not exists)
                     (not (eq major-mode dotspacemacs-scratch-mode))
                     (fboundp dotspacemacs-scratch-mode))
            (funcall dotspacemacs-scratch-mode))))
    #+end_src

    #+begin_src emacs-lisp :tangle yes
      (defun spacemacs/move-buffer-to-window (windownum follow-focus-p)
       	"Moves a buffer to a window, using the spacemacs numbering. follow-focus-p
         controls whether focus moves to new window (with buffer), or stays on
         current"
       	(interactive)
       	(let ((b (current-buffer))
              (w1 (selected-window))
              (w2 (winum-get-window-by-number windownum)))
          (unless (eq w1 w2)
            (set-window-buffer w2 b)
            (switch-to-prev-buffer)
            (unrecord-window-buffer w1 b)))
       	(when follow-focus-p (select-window (winum-get-window-by-number windownum))))
    #+end_src

    #+begin_src emacs-lisp :tangle yes
      (defun spacemacs/swap-buffers-to-window (windownum follow-focus-p)
       	"Swaps visible buffers between active window and selected window.
         follow-focus-p controls whether focus moves to new window (with buffer), or
         stays on current"
       	(interactive)
       	(let* ((b1 (current-buffer))
               (w1 (selected-window))
               (w2 (winum-get-window-by-number windownum))
               (b2 (window-buffer w2)))
          (unless (eq w1 w2)
            (set-window-buffer w1 b2)
            (set-window-buffer w2 b1)
            (unrecord-window-buffer w1 b1)
            (unrecord-window-buffer w2 b2)))
       	(when follow-focus-p (select-window-by-number windownum)))

      (dotimes (i 9)
       	(let ((n (+ i 1)))
          (eval `(defun ,(intern (format "buffer-to-window-%s" n)) (&optional arg)
                   ,(format "Move buffer to the window with number %i." n)
                   (interactive "P")
                   (if arg
                       (spacemacs/swap-buffers-to-window ,n t)
                     (spacemacs/move-buffer-to-window ,n t))))
          (eval `(defun ,(intern (format "move-buffer-window-no-follow-%s" n)) ()
                   (interactive)
                   (spacemacs/move-buffer-to-window ,n nil)))
          (eval `(defun ,(intern (format "swap-buffer-window-no-follow-%s" n)) ()
                   (interactive)
                   (spacemacs/swap-buffers-to-window ,n nil)))
          ))
    #+end_src

    #+begin_src emacs-lisp :tangle yes
      (defun spacemacs/rotate-windows-backward (count)
       	"Rotate each window backwards.
      Dedicated (locked) windows are left untouched."
       	(interactive "p")
       	(spacemacs/rotate-windows-forward (* -1 count)))
    #+end_src

    #+begin_src emacs-lisp :tangle yes
      (defun spacemacs/move-buffer-to-window (windownum follow-focus-p)
       	"Moves a buffer to a window, using the spacemacs numbering. follow-focus-p
         controls whether focus moves to new window (with buffer), or stays on
         current"
       	(interactive)
       	(let ((b (current-buffer))
              (w1 (selected-window))
              (w2 (winum-get-window-by-number windownum)))
          (unless (eq w1 w2)
            (set-window-buffer w2 b)
            (switch-to-prev-buffer)
            (unrecord-window-buffer w1 b)))
       	(when follow-focus-p (select-window (winum-get-window-by-number windownum))))
    #+end_src

    #+begin_src emacs-lisp :tangle yes
      (defun spacemacs/swap-buffers-to-window (windownum follow-focus-p)
       	"Swaps visible buffers between active window and selected window.
         follow-focus-p controls whether focus moves to new window (with buffer), or
         stays on current"
       	(interactive)
       	(let* ((b1 (current-buffer))
               (w1 (selected-window))
               (w2 (winum-get-window-by-number windownum))
               (b2 (window-buffer w2)))
          (unless (eq w1 w2)
            (set-window-buffer w1 b2)
            (set-window-buffer w2 b1)
            (unrecord-window-buffer w1 b1)
            (unrecord-window-buffer w2 b2)))
       	(when follow-focus-p (select-window-by-number windownum)))

      (dotimes (i 9)
       	(let ((n (+ i 1)))
          (eval `(defun ,(intern (format "buffer-to-window-%s" n)) (&optional arg)
                   ,(format "Move buffer to the window with number %i." n)
                   (interactive "P")
                   (if arg
                       (spacemacs/swap-buffers-to-window ,n t)
                     (spacemacs/move-buffer-to-window ,n t))))
          (eval `(defun ,(intern (format "move-buffer-window-no-follow-%s" n)) ()
                   (interactive)
                   (spacemacs/move-buffer-to-window ,n nil)))
          (eval `(defun ,(intern (format "swap-buffer-window-no-follow-%s" n)) ()
                   (interactive)
                   (spacemacs/swap-buffers-to-window ,n nil)))
          ))
    #+end_src

    #+begin_src emacs-lisp :tangle yes
      (defun spacemacs/delete-window (&optional arg)
       	"Delete the current window.
      If the universal prefix argument is used then kill the buffer too."
       	(interactive "P")
       	(if (equal '(4) arg)
            (kill-buffer-and-window)
          (delete-window)))
    #+end_src

    #+begin_src emacs-lisp :tangle yes
      ;; from http://dfan.org/blog/2009/02/19/emacs-dedicated-windows/
      (defun spacemacs/toggle-current-window-dedication ()
       	"Toggle dedication state of a window."
       	(interactive)
       	(let* ((window    (selected-window))
               (dedicated (window-dedicated-p window)))
          (set-window-dedicated-p window (not dedicated))
          (message "Window %sdedicated to %s"
                   (if dedicated "no longer " "")
                   (buffer-name))))
    #+end_src

    #+begin_src emacs-lisp :tangle yes
      ;; from https://gist.github.com/timcharper/493269
      (defun spacemacs/split-window-vertically-and-switch ()
       	(interactive)
       	(split-window-vertically)
       	(other-window 1))
    #+end_src

    #+begin_src emacs-lisp :tangle yes
      (defun spacemacs/split-window-horizontally-and-switch ()
       	(interactive)
       	(split-window-horizontally)
       	(other-window 1))
    #+end_src

    #+begin_src emacs-lisp :tangle yes
      (defun spacemacs/layout-triple-columns ()
       	" Set the layout to triple columns. "
       	(interactive)
       	(delete-other-windows)
       	(dotimes (i 2) (split-window-right))
       	(balance-windows))
    #+end_src

    #+begin_src emacs-lisp :tangle yes
      (defun spacemacs/layout-double-columns ()
       	" Set the layout to double columns. "
       	(interactive)
       	(delete-other-windows)
       	(split-window-right))
    #+end_src

    #+begin_src emacs-lisp :tangle yes
      (defun spacemacs/toggle-frame-fullscreen ()
       	"Respect the `dotspacemacs-fullscreen-use-non-native' variable when
      toggling fullscreen."
       	(interactive)
       	(if dotspacemacs-fullscreen-use-non-native
            (spacemacs/toggle-frame-fullscreen-non-native)
          (toggle-frame-fullscreen)))
    #+end_src

    #+begin_src emacs-lisp :tangle yes
      (defun spacemacs/toggle-fullscreen ()
       	"Toggle full screen on X11 and Carbon"
       	(interactive)
       	(cond
         ((eq window-system 'x)
          (set-frame-parameter nil 'fullscreen
                               (when (not (frame-parameter nil 'fullscreen))
                                 'fullboth)))
         ((eq window-system 'mac)
          (set-frame-parameter
           nil 'fullscreen
           (when (not (frame-parameter nil 'fullscreen)) 'fullscreen)))))
    #+end_src

    #+begin_src emacs-lisp :tangle yes
      (defun spacemacs/toggle-frame-fullscreen-non-native ()
       	"Toggle full screen non-natively. Uses the `fullboth' frame paramerter
         rather than `fullscreen'. Useful to fullscreen on OSX w/o animations."
       	(interactive)
       	(modify-frame-parameters
         nil
         `((maximized
            . ,(unless (memq (frame-parameter nil 'fullscreen) '(fullscreen fullboth))
                 (frame-parameter nil 'fullscreen)))
           (fullscreen
            . ,(if (memq (frame-parameter nil 'fullscreen) '(fullscreen fullboth))
                   (if (eq (frame-parameter nil 'maximized) 'maximized)
                       'maximized)
                 'fullboth)))))
    #+end_src

    #+begin_src emacs-lisp :tangle yes
      (defun spacemacs/switch-to-minibuffer-window ()
       	"switch to minibuffer window (if active)"
       	(interactive)
       	(when (active-minibuffer-window)
          (select-window (active-minibuffer-window))))
    #+end_src

    #+begin_src emacs-lisp :tangle yes
      (defun spacemacs/alternate-buffer (&optional window)
       	"Switch back and forth between current and last buffer in the
      current window."
       	(interactive)
       	(let ((current-buffer (window-buffer window)))
          ;; if no window is found in the windows history, `switch-to-buffer' will
          ;; default to calling `other-buffer'.
          (switch-to-buffer
           (cl-find-if (lambda (buffer)
                         (not (eq buffer current-buffer)))
                       (mapcar #'car (window-prev-buffers window))))))
    #+end_src

    #+begin_src emacs-lisp :tangle yes
      ;; from https://gist.github.com/3402786
      (defun spacemacs/toggle-maximize-buffer ()
       	"Maximize buffer"
       	(interactive)
       	(if (and (= 1 (length (window-list)))
                 (assoc ?_ register-alist))
            (jump-to-register ?_)
          (progn
            (window-configuration-to-register ?_)
            (delete-other-windows))))
    #+END_SRC
*** utility functions
   #+BEGIN_SRC emacs-lisp :tangle yes
      (defun my-read-expanded-filename ()
       	"Read a directory with completion and return the expanded filename"
       	(expand-file-name
         (read-file-name "dir:" )))
   #+END_SRC
   #+BEGIN_SRC emacs-lisp :tangle yes
     (defun my/make-emacs-prefix (key)
       (concat my/emacs-leader-key " " key))
     (defun my/make-evil-prefix (key)
       (concat my/evil-leader-key " " key))
     (defun my/make-emacs-mode-prefix (key)
       (concat my/emacs-mode-leader-key " " key))
     (defun my/make-evil-mode-prefix (key)
       (concat my/evil-mode-leader-key " " key))
   #+END_SRC
*** search
    #+BEGIN_SRC emacs-lisp :tangle no
      (defun my-counsel-ack-in-dir (arg)
      "Read directory with completion and call counsel-ack"
       	(interactive "P")
       	(let ((default-directory (my-read-expanded-filename))
              (initial-input ""))
              (when arg
               	(setq initial-input (word-at-point)))
              (counsel-ack "test")))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp :tangle no
      (defun my-counesl-grep-in-dir (arg)
       	"Read directory with completion and call counsel-grep"
       	(interactive"P")
       	(let ((default-directory (my-read-expanded-filename)))
          (counsel-grep)))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp :tangle no
      (defun my-counsel-ag-in-dir (arg)
      "Read directory with completion and call counsel-grep"
      (let ((default-directory (my-read-expanded-filename)))
       	(let ((default-directory (expand-file-name
                               	(read-file-name "Starting directory: "))))
       	(counsel-grep)))
    #+end_src

    #+begin_src emacs-lisp :tangle no
      (defvar my-imenu-function #'imenu
       	"Function called interctively by `my-imenu-or-similar'
       	automatically buffer local when set ")

      (defun my-imenu-or-similar ()
       	"Call the function defined in `my-imenu-function'"
       	(interactive)
       	(call-interactively my-imenu-function))

    #+END_SRC
    #+BEGIN_SRC emacs-lisp :tangle no
   (defun my-counsel-git-grep-in-dir ()


    #+END_SRC
*** editing
    #+BEGIN_SRC emacs-lisp :tangle yes
      (defun my/remove-trailing-whitespace ()
        (interactive)
        (save-excursion
          (goto-char (point-min))
          (while (re-search-forward "[ \t]+$" nil t)
            (replace-match "" nil nil)))
        nil)
    #+END_SRC
*** command wrappers
   #+BEGIN_SRC emacs-lisp :tangle yes
     (defun my/imenu ()
       "Call the function `my/imenu-function' interactively"
       (interactive)
       (call-interactively my/imenu-function))
   #+END_SRC
** vars
   #+BEGIN_SRC emacs-lisp :tangle yes
     (defvar my/evil-leader-key "SPC")
     (defvar my/emacs-leader-key "C-c s")
     (defvar my/evil-mode-leader-key ",")
     (defvar my/emacs-mode-leader-key "C-c ,")
     (defvar-local my/imenu-function 'imenu
       "Function called interactively by `my/imenu'")
   #+END_SRC

** keys
*** leader
   #+BEGIN_SRC emacs-lisp :tangle yes
     (bind-map my/base-map
       :keys (my/emacs-leader-key)
       :evil-keys (my/evil-leader-key)
       :evil-states (normal motion visual)
       :override-minor-modes t
       :bindings
       ("0" 'winum-select-window-0-or-10
        "1" 'winum-select-window-1
        "2" 'winum-select-window-2
        "3" 'winum-select-window-3
        "4" 'winum-select-window-4
        "5" 'winum-select-window-5
        "6" 'winum-select-window-6
        "7" 'winum-select-window-7
        "8" 'winum-select-window-8
        "9" 'winum-select-window-9
        "!" 'shell-command
        "v" 'er/expand-region
        ";" 'evilnc-comment-operator
        ":" 'evilnc-comment-and-copy-operator
        "SPC" 'counsel-M-x
        "TAB" 'spacemacs/alternate-buffer
        "u" 'universal-argument
        "d" 'dired
        "'" 'my/main-shell
        "/" 'my/buffer-shell))
     (bind-map my/mode-leader-map
       :evil-keys (my/evil-mode-leader-key)
       :evil-keys (my/emacs-mode-leader-key)
       :evil-states (normal motion visual)
       :override-minor-modes t)
   #+END_SRC
*** errors
    #+BEGIN_SRC emacs-lisp :tangle yes
      (bind-map my/errors-map
            :keys ((my/make-emacs-prefix "e"))
            :evil-keys ((my/make-evil-prefix "e"))
            :evil-states (normal motion visual)
            :override-mode-name buffer-keys
            :prefix-cmd errors
            :bindings
            ("n" 'next-error
            "p" 'previous-error))
 #+END_SRC

*** buffers
    #+BEGIN_SRC emacs-lisp :tangle yes
      (bind-map my/buffers-map
	:keys ((my/make-emacs-prefix "b"))
	:evil-keys ((my/make-evil-prefix "b"))
	:evil-states (normal motion visual)
	:prefix-cmd buffers
	:bindings
	("." 'spacemacs/buffer-transient-state/body
	"1" 'buffer-to-window-1
	"2" 'buffer-to-window-2
	"3" 'buffer-to-window-3
	"4" 'buffer-to-window-4
	"5" 'buffer-to-window-5
	"6" 'buffer-to-window-6
	"7" 'buffer-to-window-7
	"8" 'buffer-to-window-8
	"9" 'buffer-to-window-9
	"B" 'ibuffer
	"N" 'spacemacs/new-empty-buffer
	"P" 'spacemacs/copy-clipboard-to-whole-buffer
	"R" 'spacemacs/safe-revert-buffer
	"Y" 'spacemacs/copy-whole-buffer-to-clipboard
	"b" 'switch-to-buffer
	"d" 'spacemacs/kill-this-buffer
	"e" 'spacemacs/safe-erase-buffer
	"I" 'ibuffer
	"m" 'spacemacs/kill-other-buffers
	"n" 'next-buffer
	"p" 'previous-buffer
	"s" 'spacemacs/switch-to-scratch-buffer
	"w" 'read-only-mode))
    #+END_SRC

*** Windows
    #+BEGIN_SRC emacs-lisp :tangle yes
      (bind-map my/windows-map
        :keys ((my/make-emacs-prefix "w"))
        :evil-keys ((my/make-evil-prefix "w"))
        :evil-states (normal motion visual)
        :prefix-cmd windows
        :bindings
        ("w" 'other-window
         "o" 'other-frame
         "s" 'split-window-below
         "S" 'split-window-below-and-focus
         "v" 'split-window-right
         "V" 'split-window-right-and-focus
         "=" 'balance-windows
         "S" 'split-window-below-and-focus
         "V" 'split-window-right-and-focus
         "u" 'winner-undo
         "U" 'winner-redo
         "2" 'spacemacs/layout-double-columns
         "3" 'spacemacs/layout-triple-columns
         "_" 'spacemacs/maximize-horizontally
         "b" 'spacemacs/switch-to-minibuffer-window
         "d" 'spacemacs/delete-window
         "D" 'delete-frame
         "m" 'spacemacs/toggle-maximize-buffer
         "r" 'spacemacs/rotate-windows-forward
         "=" 'balance-windows
         "F" 'make-frame
         "h" 'evil-window-left
         "j" 'evil-window-down
         "k" 'evil-window-up
         "l" 'evil-window-right
         "H" 'evil-window-move-far-left
         "J" 'evil-window-move-very-bottom
         "K" 'evil-window-move-very-top
         "L" 'evil-window-move-far-right
         "<S-down>" 'evil-window-move-very-bottom
         "<S-left>" 'evil-window-move-far-left
         "<S-right>" 'evil-window-move-far-right
         "<S-up>" 'evil-window-move-very-top
         "<down>" 'evil-window-down
         "<left>" 'evil-window-left
         "<right>" 'evil-window-right
         "<up>" 'evil-window-up))
    #+END_SRC

*** Files
    #+BEGIN_SRC emacs-lisp :tangle yes
      (bind-map my/files-map
        :keys ((my/make-emacs-prefix "f"))
        :evil-keys ((my/make-evil-prefix "f"))
        :evil-states (normal motion visual)
        :prefix-cmd file
        :bindings
        ("S" 'save-some-buffers
         "b" 'counsel-bookmark
         "g" 'rgrep
         "j" 'dired-jump
         "J" 'dired-jump-other-window
         "f" 'find-file
         "l" 'find-file-literally
         "r" 'counsel-recentf
         "s" 'save-buffer
         "y" 'spacemacs/show-and-copy-buffer-filename
         "vd" 'add-dir-local-variable
         "vf" 'add-file-local-variable
         "vp" 'add-file-local-variable-prop-line))
    #+END_SRC

*** compile/comment
   #+BEGIN_SRC emacs-lisp :tangle yes
     (bind-map my/compile-comment-map
       :keys ((my/make-emacs-prefix "c"))
       :evil-keys ((my/make-evil-prefix "c"))
       :evil-states (normal motion visual)
       :prefix-cmd compile-comment
       :bindings
       ("c" 'compile
        "r" 'recompile
        "k" 'kill-compilation
        "l" 'my-comment-or-uncomment-region-or-line))
   #+END_SRC

*** Project
   #+BEGIN_SRC emacs-lisp :tangle yes
          (bind-map my/projectile-map
            :keys ((my/make-emacs-prefix "p"))
            :evil-keys ((my/make-evil-prefix "p"))
            :evil-states (normal motion visual)
            :prefix-cmd projectile
            :bindings
            (
     ;;"SPC" 'counsel-projectile
             ;; "!" 'projectile-run-shell-command-in-root
             ;; "%" 'projectile-replace-regexp
             ;; "&" 'projectile-run-async-shell-command-in-root
             ;; "D" 'projectile-dired
             ;; "F" 'projectile-find-file-dwim
             ;; "G" 'projectile-regenerate-tags
             ;; "I" 'projectile-invalidate-cache
             ;; "R" 'projectile-replace
             ;; "T" 'projectile-test-project
             ;; "a" 'projectile-toggle-between-implementation-and-test
             ;; "c" 'projectile-compile-project
             ;; "e" 'projectile-edit-dir-locals
             ;; "g" 'projectile-find-tag
             ;; "k" 'projectile-kill-buffers
             ;; "r" 'projectile-recentf
     ))
   #+END_SRC

*** search
    #+BEGIN_SRC emacs-lisp :tangle yes
      (bind-map my/search-map
        :keys ((my/make-emacs-prefix "s"))
        :evil-keys ((my/make-evil-prefix "s"))
        :evil-states (normal motion visual)
        :prefix-cmd search/symbol
        :bindings
        )
    #+END_SRC

*** git
    #+BEGIN_SRC emacs-lisp :tangle yes
      (bind-map my/git-map
        :keys ((my/make-emacs-prefix "g"))
        :evil-keys ((my/make-evil-prefix "g"))
        :evil-states (normal motion visual)
        :prefix-cmd git)
    #+end_src
**** git file
    #+begin_src emacs-lisp :tangle yes
      (bind-map my/git-file-map
        :keys ((concat my/emacs-leader-key " g f"))
        :evil-keys ((concat my/evil-leader-key " g f"))
        :evil-states (normal motion visual)
        :prefix-cmd git-file)
    #+END_SRC

*** Jump/join
    #+BEGIN_SRC emacs-lisp :tangle yes
      (bind-map my/jump-join-map
        :keys ((my/make-emacs-prefix "j"))
        :evil-keys ((my/make-evil-prefix "j"))
        :evil-states (normal motion visual)
        :prefix-cmd jump-join
        :bindings
        ("D" 'dired-jump-other-window
         "S" 'spacemacs/split-and-new-line
         "d" 'dired-jump
         "f" 'find-function
         "i" 'my/imenu
         "o" 'open-line
         "q" 'dumb-jump-quick-look
         "s" 'sp-split-sexp
         "v" 'find-variable
))
    #+END_SRC

*** insert
    #+BEGIN_SRC emacs-lisp :tangle yes
      (bind-map my/insert-map
        :keys ((my/make-emacs-prefix "i"))
        :evil-keys ((my/make-evil-prefix "i"))
        :evil-states (normal motion visual)
        :prefix-cmd inserting)
    #+END_SRC

*** text 
     #+BEGIN_SRC emacs-lisp :tangle yes
       (bind-map my/text-map
         :keys ((my/make-emacs-prefix "x"))
         :evil-keys ((my/make-evil-prefix "x"))
         :evil-states (normal motion visual)
         :prefix-cmd text
         :bindings
         ("TAB" 'indent-rigidly
          "c" 'transpose-chars
          "e" 'transpose-sexps
          "l" 'transpose-lines
          "p" 'transpose-paragraphs
          "s" 'transpose-sentences
          "w" 'transpose-words))
     #+end_src
**** TODO more from spacemacs to implement 
     #+begin_src emacs-lisp :tangle no
       SPC x j c       set-justification-center
       SPC x j f       set-justification-full
       SPC x j l       set-justification-left
       SPC x j n       set-justification-none
       SPC x j r       set-justification-right
       (use-package string-inflection
       SPC x i -       string-inflection-kebab-case
       SPC x i C       string-inflection-camelcase
       SPC x i U       string-inflection-upcase
       SPC x i _       string-inflection-underscore
       SPC x i c       string-inflection-lower-camelcase
       SPC x i k       string-inflection-kebab-case
       SPC x i u       string-inflection-underscore)
         :ensure t)
       (use-package google-translare
       SPC x g Q       google-translate-query-translate-reverse
       SPC x g T       google-translate-at-point-reverse
       SPC x g l       spacemacs/set-google-translate-languages
       SPC x g q       google-translate-query-translate
       SPC x g t       google-translate-at-point
         :ensure t)

       SPC x a %       spacemacs/align-repeat-percent
       SPC x a &       spacemacs/align-repeat-ampersand
       SPC x a (       spacemacs/align-repeat-left-paren
       SPC x a )       spacemacs/align-repeat-right-paren
       SPC x a ,       spacemacs/align-repeat-comma
       SPC x a .       spacemacs/align-repeat-decimal
       SPC x a :       spacemacs/align-repeat-colon
       SPC x a ;       spacemacs/align-repeat-semicolon
       SPC x a =       spacemacs/align-repeat-equal
       SPC x a L       evil-lion-right
       SPC x a [       spacemacs/align-repeat-left-square-brace
       SPC x a \       spacemacs/align-repeat-backslash
       SPC x a ]       spacemacs/align-repeat-right-square-brace
       SPC x a a       align
       SPC x a c       align-current
       SPC x a l       evil-lion-left
       SPC x a m       spacemacs/align-repeat-math-oper
       SPC x a r       spacemacs/align-repeat
       SPC x a {       spacemacs/align-repeat-left-curly-brace
       SPC x a |       spacemacs/align-repeat-bar
       SPC x a }       spacemacs/align-repeat-right-curly-brace
       SPC x r '       rxt-convert-to-strings
       SPC x r /       rxt-explain
       SPC x r c       rxt-convert-syntax
       SPC x r e       Prefix Command
       SPC x r p       Prefix Command
       SPC x r t       rxt-toggle-elisp-rx
       SPC x r x       rxt-convert-to-rx

       SPC x r p '     rxt-pcre-to-strings
       SPC x r p /     rxt-explain-pcre
       SPC x r p e     rxt-pcre-to-elisp
       SPC x r p x     rxt-pcre-to-rx

       SPC x r e '     rxt-elisp-to-strings
       SPC x r e /     rxt-explain-elisp
       SPC x r e p     rxt-elisp-to-pcre
       SPC x r e t     rxt-toggle-elisp-rx
       SPC x r e x     rxt-elisp-to-rx



     #+END_SRC
***  registers/rings/resume
     #+BEGIN_SRC emacs-lisp :tangle yes
       (bind-map my/reg-ring-resume-map
         :keys ((my/make-emacs-prefix "r"))
         :evil-keys ((my/make-evil-prefix "r"))
         :evil-states (normal motion visual)
         :prefix-cmd regs-rings-resume)
    #+END_SRC
** evil
*** evil
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package evil
       	:ensure t
       	:init
       	(setq evil-want-integration nil)
       	:config
       	(evil-mode 1))
    #+END_SRC
*** evil-collection
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package evil-collection
        :after evil
        :ensure t
        :bind
        (:map jump-join ("j" . evil-avy-goto-char-timer) ("l"
         . evil-avy-goto-line) ("w"
         . evil-avy-goto-word-or-subword-1))
        :config
        (evil-collection-init))
    #+END_SRC

*** evil-rsi
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package evil-rsi
       	:ensure t
       	:requires evil)
    #+END_SRC

*** evil-iedit-state
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package evil-iedit-state
        :ensure t
        :bind
        (:map my/search-map ("e" . evil-iedit-state/iedit-mode)))
    #+END_SRC
*** evil-escape
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package evil-escape
       	:ensure t
       	:requires evil
       	:config
       	(evil-escape-mode 1))
    #+END_SRC

*** evil-nerd-commenter
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package evil-nerd-commenter
       	:ensure t
       	:requires evil)
    #+END_SRC

*** evil-surround
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package evil-surround
       	:ensure t
            :init
            (add-hook 'after-init-hook 'global-evil-surround-mode)
            :requires evil)
    #+END_SRC

*** evil-exchange
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package evil-exchange
       	:ensure t
       	:requires evil
       	:config
       	(evil-exchange-cx-install))
    #+END_SRC

*** evil-unimpaired
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package evil-unimpaired
       	:load-path "sumodules/evil-unimpaired"
       	:requires evil
       	:init
       	(add-hook 'evil-mode-hook 'evil-unimpaired-mode))
    #+END_SRC

*** evil-rsi
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package evil-rsi
       	:ensure t
       	:requires evil
       	:config (evil-rsi-mode 1))
    #+END_SRC

*** org-evil
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package org-evil
         :ensure t
         :requires evil)
    #+END_SRC
*** keybindings
  #+BEGIN_SRC emacs-lisp :tangle yes
  (evil-define-key '(insert normal visual) 'global-map (kbd "M-/")
    'hippie-expand)
  #+END_SRC  
** ivy
*** ivy
    #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package ivy
       :ensure t
       :bind 
       (:map ivy-minibuffer-map (" " . ivy-alt-done) ("C-j"
        . ivy-next-line) ("C-k" . ivy-previous-line) ("C-h"
        . 'ivy-backward-delete-char)
        :map my/reg-ring-resume-map
        ("m" . counsel-mark-ring) ("y" . counsel-yank-pop)) ("l"
        . ivy-resume)
       :init
       (add-hook 'after-init-hook 'ivy-mode)
       :config
       (evil-set-initial-state 'ivy-occur-grep-mode 'normal)
       (evil-make-overriding-map ivy-occur-mode-map 'normal))
   #+END_SRC
    
*** ivy-yasnippet
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package ivy-yasnippet
        :ensure t
        :bind 
        (:map my/insert-map ("y" . ivy-yasnippet)))
    #+END_SRC
*** ivy-hydra
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package ivy-hydra
       :ensure t
       :requires (ivy))
   #+END_SRC

*** counsel
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package counsel
       :ensure t
       :bind 
       (:map my/search-map ("k" . counsel-ack) ("g"
        . counsel-git-grep) ("s" . swiper) ("K" . ack) ("k"
        . counsel-ack) ("g" . counsel-git-grep) ("G" . vc-git-grep)
        ("a" . counsel-ag) ("A" . ag))
        :config
        (counsel-mode))
   #+END_SRC

** editing
*** iedit
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package iedit
       :ensure t)
   #+END_SRC
*** which-key
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package which-key
       :ensure t
       :init
       (add-hook 'after-init-hook 'which-key-mode))
   #+END_SRC

*** move-text
    #+BEGIN_SRC emacs-lisp :tangle yes
   (use-package move-text
     :ensure t
     :init
     (add-hook 'after-init-hook 'which-key-mode))
    #+END_SRC

*** undo-tree
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package undo-tree
    :ensure t)
#+END_SRC

*** expand-region
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package expand-region
    :ensure t)
#+END_SRC
    
*** evil-multiple-cursors
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package evil-mc
       	:ensure t
       	:requires evil
       	:config)
    #+END_SRC
** visual
   #+begin_src emacs-lisp :tangle no

   (use-package hl-anything
     :ensure t
     :config
     ) (use-package hl-indent
     :ensure t
     :config
     (add-hook 'prog-mode-hook 'hl-indent) ) (use-package hl-sentence
     :ensure t
     ) (use-package hl-todo
     :ensure t
     :config
     (global-hl-todo-mode) ) (
   #+END_SRC  
** completion
*** yasnippet
#+BEGIN_SRC emacs-lisp :tangle yes
    (use-package yasnippet
        :ensure t
        :defer t
        :init
        (add-hook 'prog-mode-hook 'yas-minor-mode) (add-hook
        'org-mode-hook 'yas-minor-mode)
        :config
        (add-to-list 'hippie-expand-try-functions-list
        'yas-hippie-try-expand) (yas-reload-all)) (use-package
        yasnippet-snippets
        :ensure t
        :requires yasnippet)
#+END_SRC

*** flycheck
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package flycheck
    :ensure t
    :bind
    (:map my/errors-map ("." . spacemacs/error-transient-state/body)
     ("S" . flycheck-set-checker-executable) ("b" . flycheck-buffer)
     ("c" . flycheck-clear) ("h" . flycheck-describe-checker) ("l"
     . my/flycheck-toggle-error-list) ("s" . flycheck-select-checker)
     ("v" . flycheck-verify-setup) ("x"
     . flycheck-explain-error-at-point) ("y"
     . flycheck-copy-errors-as-kill)))
#+END_SRC
**** funcs
     #+BEGIN_SRC emacs-lisp :tangle yes
       (defun my/flycheck-toggle-error-list () "Toggle flycheck's
         error list window" (interactive) (-if-let (window
         (flycheck-get-error-list-window)) (quit-window nil window)
         (flycheck-list-errors)))
     #+END_SRC

*** company
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package company
       	:ensure t
       	:config
       	(setq company-backends '((company-dabbrev-code company-gtags
              company-etags company-keywords) company-files
              company-dabbrev)))
     #+END_SRC

** navigation
*** grep/ack/wgrep
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package ag
    :ensure t)
#+END_SRC


#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package ack
    :ensure t)
#+END_SRC


#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package wgrep
    :ensure t)
#+END_SRC


#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package wgrep-ack
    :ensure t)
#+END_SRC


#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package wgrep-ag
    :ensure t)
#+END_SRC

*** avy
#+BEGIN_SRC emacs-lisp :tangle yes
    (use-package avy
      :ensure t
      :bind
      (:map my/jump-join-map ("b" . avy-pop-mark) ("w"
       . evil-avy-goto-word-or-subword-1) ("b" . avy-pop-mark)))
#+END_SRC

*** link-hint
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package link-hint
        :ensure t
        :bind
        (:map
         my/jump-join-map
         ("h" . link-hint-open-link)))
    #+END_SRC
** windows and buffers
*** winum-mode
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package winum
    :ensure t
    :config
    (winum-mode))
#+END_SRC

** magit
*** magit
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package magit
    :ensure t
    :bind
    (:map my/git-map
     ("s" . magit-status)
     ("A" . magit-cherry-pick-popup)
     ("b" . magit-branch-popup)
     ("b" . magit-bisect-popup)
     ("c" . magit-commit-popup)
     ("d" . magit-diff-popup)
     ("f" . magit-fetch-popup)
     ("F" . magit-pull-popup)
     ("l" . magit-log-popup)
     ("P" . magit-pushing-popup)
     ("r" . magit-rebase-popup)
     ("t" . magit-tag-popup)
     ("T" . magit-notes-popup)
     ("_" . magit-revert-popup)
     ("O" . magit-revert-popup)
     ("z" . magit-stash-popup)
     ("!" . magit-run-popup)
     :map my/git-file-map
     ("f" . magit-find-file)
     ("d" . magit-diff-buffer-file-popup)
     ("f" . magit-find-file)
     ("l" . magit-log-buffer-file)))
#+END_SRC
*** evil-magit
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package evil-magit
        :after evil
        :ensure t
        :init
        :config
        (evil-magit-init))
    #+END_SRC
** projectile
*** projectile
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package projectile
        :config
        (projectile-mode)
        :ensure t
        :bind
        (:map
         my/projectile-map
         ("!" . projectile-run-shell-command-in-root)
         ("%" . projectile-replace-regexp)
         ("&" . projectile-run-async-shell-command-in-root)
         ("d" . projectile-dired)
         ("D" . projectile-dired-other-window)
         ("F" . projectile-find-file-dwim)
         ("G" . projectile-regenerate-tags)
         ("I" . projectile-invalidate-cache)
         ("R" . projectile-replace)
         ("T" . projectile-test-project)
         ("a" . projectile-toggle-between-implementation-and-test)
         ("c" . projectile-compile-project)
         ("e" . projectile-edit-dir-locals)
         ("g" . projectile-find-tag)
         ("k" . projectile-kill-buffers)
         ("v" . projectile-vc)
         ("b" . projectile-switch-to-buffer)
         ("B" . projectile-ibuffer)
         ("f" . projectile-find-file)
         ("p" . projectile-lost-packages)
         ("r" . projectile-recentf)))
    #+END_SRC
*** counsel-projectile
    #+begin_src emacs-lisp :tangle no
      (use-package counsel-projectile
        :ensure t
        :bind
        (:map 
         my/projectile-map
         ("SPC" . counsel-projectile)
         ("b" . counsel-projectile-switch-to-buffer)
         ("f" . counsel-projectile-find-file)
         ("d" . counsel-projectile-find-dir)
         ("p" . counsel-projectile-switch-project)))

    #+end_src
*** ibuffer-projectile
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package ibuffer-projectile
        :ensure t
        :config
        (ibuffer-projectile-set-filter-groups))
    #+END_SRC
** hydra
   #+BEGIN_SRC emacs-lisp :tangle yes
  (use-package hydra
    :ensure t)
   #+END_SRC
** theme
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package solarized-theme
       :config
       (load-theme 'solarized-dark t)
       :ensure t)
   #+END_SRC
   
** configuration
*** minor-modes
    #+BEGIN_SRC emacs-lisp :tangle yes
     (menu-bar-mode 0)
     (tool-bar-mode 0)
     (scroll-bar-mode 0)
     (global-hl-line-mode)
     (setq initial-major-mode 'text-mode)
     (winner-mode 1)
    #+END_SRC
*** backup files
    Keep temporary files to a backup-directory in emacs directory
    #+BEGIN_SRC emacs-lisp :tangle no
     (defvar tramp-backup-directory-alist)
     (defvar tramp-auto-save-directory)
     (let ((backup-dir "~/.emacs.d/.backups")
           (auto-saves-dir "~/.emacs.d/.auto-saves/"))
       (dolist (dir (list backup-dir auto-saves-dir))
         (when (not (file-directory-p dir))
           (make-directory dir t)))
       (setq backup-directory-alist `(("." . ,backup-dir))
             auto-save-file-name-transforms `((".*" ,auto-saves-dir t))
             auto-save-list-file-prefix (concat auto-saves-dir ".saves-")
             tramp-backup-directory-alist `((".*" . ,backup-dir))
             tramp-auto-save-directory auto-saves-dir))
     (setq backup-by-copying t    ; Don't delink hardlinks
           delete-old-versions t  ; Clean up the backups
           version-control t      ; Use version numbers on backups,
           kept-new-versions 5    ; keep some new versions
           kept-old-versions 2)   ; and some old ones, too)
    #+END_SRC
    
    Keep custom variables in a separate gitignored file to allow local customizations
    using customize
*** custom-vars
    #+BEGIN_SRC emacs-lisp :tangle yes
  (let ((path (concat user-emacs-directory "custom.el")))
    (unless (file-exists-p path) (write-region "" nil path))
    (setq custom-file path))
    #+END_SRC
    
** shell
*** vars
    #+BEGIN_SRC emacs-lisp :tangle yes
       (defcustom my-shell-program
       	 "/bin/bash"
       	 "Path to shell binary for shell opened by `my-shell-toggle-shell'"
       	 :group 'my-shell)

       (defcustom my-shell-buffer-name-regex
       	 "^\\*term-.*\\*$"
       	 "Regexp used to identify if the current window is a term buffer"
       	 :group 'my-shell)
    #+END_SRC
    
*** funcs
    #+BEGIN_SRC emacs-lisp :tangle yes
       	(defun my-shell-toggle-shell(shell-buffer-name)
       	  "Toggle a window and run program defined in `my-shell-program'
       	If a buffer SHELL-BUFFER-NAME reuse, else start a new term process"
       	  (if (string-match "^\\*term-.*\\*$" (buffer-name))
              (delete-window)
            (select-window (split-window-below))
            (let ((buffer (get-buffer shell-buffer-name)))
              (if buffer
               	  (switch-to-buffer buffer)
               	(term my-shell-program)
               	(rename-buffer shell-buffer-name)))))
    #+END_SRC
    
    #+BEGIN_SRC emacs-lisp :tangle yes
       	(defun my/main-shell ()
       	  "Toggle the main shell"
       	  (interactive)
       	  (my-shell-toggle-shell "*term-main*"))

       	(defun my/buffer-shell ()
       	  "Toggle a buffer local shell"
       	  (interactive)
       	  (my-shell-toggle-shell (concat "*term-" (buffer-name) "*")))

       	(provide 'my-shell)
       	;;; my-shell.el ends here
    #+END_SRC
    
*** keys
    #+BEGIN_SRC emacs-lisp :tangle yes
      (bind-map-set-keys my/base-map
        "'" 'my/main-shell
        "/" 'my/buffer-shell)
    #+END_SRC
***  help-highlight
    #+BEGIN_SRC emacs-lisp :tangle yes
      (bind-map my/help-highlight-map
        :keys ((my/make-emacs-prefix "h"))
        :evil-keys ((my/make-evil-prefix "h"))
        :evil-states (normal motion visual)
        :prefix-cmd help-highlight)
    #+END_SRC 
** evil
*** evil
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package evil
       	:ensure t
       	:init
       	(setq evil-want-integration nil)
       	:config
       	(evil-mode 1))
    #+END_SRC
*** evil-collection
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package evil-collection
        :after evil
        :ensure t
        :bind
        (:map jump-join ("j" . evil-avy-goto-char-timer) ("l"
         . evil-avy-goto-line) ("w"
         . evil-avy-goto-word-or-subword-1))
        :config
        (evil-collection-init))
    #+END_SRC

*** evil-rsi
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package evil-rsi
       	:ensure t
       	:requires evil)
    #+END_SRC

*** evil-iedit-state
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package evil-iedit-state
        :ensure t
        :bind
        (:map my/search-map ("e" . evil-iedit-state/iedit-mode)))
    #+END_SRC
*** evil-escape
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package evil-escape
       	:ensure t
       	:requires evil
       	:config
       	(evil-escape-mode 1))
    #+END_SRC

*** evil-nerd-commenter
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package evil-nerd-commenter
       	:ensure t
       	:requires evil)
    #+END_SRC

*** evil-surround
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package evil-surround
       	:ensure t
            :init
            (add-hook 'after-init-hook 'global-evil-surround-mode)
            :requires evil)
    #+END_SRC

*** evil-exchange
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package evil-exchange
       	:ensure t
       	:requires evil
       	:config
       	(evil-exchange-cx-install))
    #+END_SRC

*** evil-unimpaired
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package evil-unimpaired
       	:load-path "sumodules/evil-unimpaired"
       	:requires evil
       	:init
       	(add-hook 'evil-mode-hook 'evil-unimpaired-mode))
    #+END_SRC

*** evil-rsi
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package evil-rsi
       	:ensure t
       	:requires evil
       	:config (evil-rsi-mode 1))
    #+END_SRC

*** org-evil
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package org-evil
         :ensure t
         :requires evil)
    #+END_SRC
*** keybindings
  #+BEGIN_SRC emacs-lisp :tangle yes
  (evil-define-key '(insert normal visual) 'global-map (kbd "M-/")
    'hippie-expand)
  #+END_SRC  
** ivy
*** ivy
    #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package ivy
       :ensure t
       :bind 
       (:map ivy-minibuffer-map (" " . ivy-alt-done) ("C-j"
        . ivy-next-line) ("C-k" . ivy-previous-line) ("C-h"
        . 'ivy-backward-delete-char)
        :map my/reg-ring-resume-map
        ("m" . counsel-mark-ring) ("y" . counsel-yank-pop)) ("l"
        . ivy-resume)
       :init
       (add-hook 'after-init-hook 'ivy-mode)
       :config
       (evil-set-initial-state 'ivy-occur-grep-mode 'normal)
       (evil-make-overriding-map ivy-occur-mode-map 'normal))
   #+END_SRC
    
*** ivy-yasnippet
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package ivy-yasnippet
        :ensure t
        :bind 
        (:map my/insert-map ("y" . ivy-yasnippet)))
    #+END_SRC
*** ivy-hydra
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package ivy-hydra
       :ensure t
       :requires (ivy))
   #+END_SRC

*** counsel
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package counsel
       :ensure t
       :bind 
       (:map my/search-map ("k" . counsel-ack) ("g"
        . counsel-git-grep) ("s" . swiper) ("K" . ack) ("k"
        . counsel-ack) ("g" . counsel-git-grep) ("G" . vc-git-grep)
        ("a" . counsel-ag) ("A" . ag))
        :config
        (counsel-mode))
   #+END_SRC

** editing
*** iedit
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package iedit
       :ensure t)
   #+END_SRC
*** which-key
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package which-key
       :ensure t
       :init
       (add-hook 'after-init-hook 'which-key-mode))
   #+END_SRC

*** move-text
    #+BEGIN_SRC emacs-lisp :tangle yes
   (use-package move-text
     :ensure t
     :init
     (add-hook 'after-init-hook 'which-key-mode))
    #+END_SRC

*** undo-tree
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package undo-tree
    :ensure t)
#+END_SRC

*** expand-region
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package expand-region
    :ensure t)
#+END_SRC
    
*** evil-multiple-cursors
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package evil-mc
       	:ensure t
       	:requires evil
       	:config)
    #+END_SRC
** visual
   #+begin_src emacs-lisp :tangle no

   (use-package hl-anything
     :ensure t
     :config
     ) (use-package hl-indent
     :ensure t
     :config
     (add-hook 'prog-mode-hook 'hl-indent) ) (use-package hl-sentence
     :ensure t
     ) (use-package hl-todo
     :ensure t
     :config
     (global-hl-todo-mode) ) (
   #+END_SRC  
** completion
*** yasnippet
#+BEGIN_SRC emacs-lisp :tangle yes
    (use-package yasnippet
        :ensure t
        :defer t
        :init
        (add-hook 'prog-mode-hook 'yas-minor-mode) (add-hook
        'org-mode-hook 'yas-minor-mode)
        :config
        (add-to-list 'hippie-expand-try-functions-list
        'yas-hippie-try-expand) (yas-reload-all)) (use-package
        yasnippet-snippets
        :ensure t
        :requires yasnippet)
#+END_SRC

*** flycheck
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package flycheck
    :ensure t
    :bind
    (:map my/errors-map ("." . spacemacs/error-transient-state/body)
     ("S" . flycheck-set-checker-executable) ("b" . flycheck-buffer)
     ("c" . flycheck-clear) ("h" . flycheck-describe-checker) ("l"
     . my/flycheck-toggle-error-list) ("s" . flycheck-select-checker)
     ("v" . flycheck-verify-setup) ("x"
     . flycheck-explain-error-at-point) ("y"
     . flycheck-copy-errors-as-kill)))
#+END_SRC
**** funcs
     #+BEGIN_SRC emacs-lisp :tangle yes
       (defun my/flycheck-toggle-error-list () "Toggle flycheck's
         error list window" (interactive) (-if-let (window
         (flycheck-get-error-list-window)) (quit-window nil window)
         (flycheck-list-errors)))
     #+END_SRC

*** company
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package company
       	:ensure t
       	:config
       	(setq company-backends '((company-dabbrev-code company-gtags
              company-etags company-keywords) company-files
              company-dabbrev)))
     #+END_SRC

** navigation
*** avy
#+BEGIN_SRC emacs-lisp :tangle yes
    (use-package avy
      :ensure t
      :bind
      (:map my/jump-join-map ("b" . avy-pop-mark) ("w"
       . evil-avy-goto-word-or-subword-1) ("b" . avy-pop-mark)))
#+END_SRC

*** grep/ack/wgrep
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package ag
    :ensure t)
#+END_SRC


#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package ack
    :ensure t)
#+END_SRC


#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package wgrep
    :ensure t)
#+END_SRC


#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package wgrep-ack
    :ensure t)
#+END_SRC


#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package wgrep-ag
    :ensure t)
#+END_SRC

** windows and buffers
*** winum-mode
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package winum
    :ensure t
    :config
    (winum-mode))
#+END_SRC

** magit
*** magit
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package magit
    :ensure t
    :bind
    (:map my/git-map
     ("s" . magit-status)
     ("A" . magit-cherry-pick-popup)
     ("b" . magit-branch-popup)
     ("b" . magit-bisect-popup)
     ("c" . magit-commit-popup)
     ("d" . magit-diff-popup)
     ("f" . magit-fetch-popup)
     ("F" . magit-pull-popup)
     ("l" . magit-log-popup)
     ("P" . magit-pushing-popup)
     ("r" . magit-rebase-popup)
     ("t" . magit-tag-popup)
     ("T" . magit-notes-popup)
     ("_" . magit-revert-popup)
     ("O" . magit-revert-popup)
     ("z" . magit-stash-popup)
     ("!" . magit-run-popup)
     :map my/git-file-map
     ("f" . magit-find-file)
     ("d" . magit-diff-buffer-file-popup)
     ("f" . magit-find-file)
     ("l" . magit-log-buffer-file)))
#+END_SRC
*** evil-magit
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package evil-magit
        :after evil
        :ensure t
        :init
        :config
        (evil-magit-init))
    #+END_SRC
** projectile
*** COMMENT projectile
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package projectile
        :config
        (projectile-mode)
        :ensure t
        :bind
        (:map
         my/projectile-map
         ("!" . projectile-run-shell-command-in-root)
         ("%" . projectile-replace-regexp)
         ("&" . projectile-run-async-shell-command-in-root)
         ("d" . projectile-dired)
         ("D" . projectile-dired-other-window)
         ("F" . projectile-find-file-dwim)
         ("G" . projectile-regenerate-tags)
         ("I" . projectile-invalidate-cache)
         ("R" . projectile-replace)
         ("T" . projectile-test-project)
         ("a" . projectile-toggle-between-implementation-and-test)
         ("c" . projectile-compile-project)
         ("e" . projectile-edit-dir-locals)
         ("g" . projectile-find-tag)
         ("k" . projectile-kill-buffers)
         ("v" . projectile-vc)
         ("b" . projectile-switch-to-buffer)
         ("B" . projectile-ibuffer)
         ("f" . projectile-find-file)
         ("p" . projectile-lost-packages)
         ("r" . projectile-recentf)))
    #+END_SRC
*** counsel-projectile
    #+begin_src emacs-lisp :tangle no
      (use-package counsel-projectile
        :ensure t
        :bind
        (:map 
my/projectile-map
              ("SPC" . counsel-projectile)
              ("b" . counsel-projectile-switch-to-buffer)
              ("f" . counsel-projectile-find-file)
              ("d" . counsel-projectile-find-dir)
              ("p" . counsel-projectile-switch-project)))

    #+end_src
    
** hydra
   #+BEGIN_SRC emacs-lisp :tangle yes
  (use-package hydra
    :ensure t)
   #+END_SRC
** theme
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package solarized-theme
       :config
       (load-theme 'solarized-dark t)
       :ensure t)
   #+END_SRC
   
** configuration
*** minor-modes
    #+BEGIN_SRC emacs-lisp :tangle yes
     (menu-bar-mode 0)
     (tool-bar-mode 0)
     (scroll-bar-mode 0)
     (global-hl-line-mode)
     (setq initial-major-mode 'text-mode)
     (winner-mode 1)
    #+END_SRC
*** backup files
    Keep temporary files to a backup-directory in emacs directory
    #+BEGIN_SRC emacs-lisp :tangle no
     (defvar tramp-backup-directory-alist)
     (defvar tramp-auto-save-directory)
     (let ((backup-dir "~/.emacs.d/.backups")
           (auto-saves-dir "~/.emacs.d/.auto-saves/"))
       (dolist (dir (list backup-dir auto-saves-dir))
         (when (not (file-directory-p dir))
           (make-directory dir t)))
       (setq backup-directory-alist `(("." . ,backup-dir))
             auto-save-file-name-transforms `((".*" ,auto-saves-dir t))
             auto-save-list-file-prefix (concat auto-saves-dir ".saves-")
             tramp-backup-directory-alist `((".*" . ,backup-dir))
             tramp-auto-save-directory auto-saves-dir))
     (setq backup-by-copying t    ; Don't delink hardlinks
           delete-old-versions t  ; Clean up the backups
           version-control t      ; Use version numbers on backups,
           kept-new-versions 5    ; keep some new versions
           kept-old-versions 2)   ; and some old ones, too)
    #+END_SRC
    
    Keep custom variables in a separate gitignored file to allow local customizations
    using customize
*** custom-vars
    #+BEGIN_SRC emacs-lisp :tangle yes
  (let ((path (concat user-emacs-directory "custom.el")))
    (unless (file-exists-p path) (write-region "" nil path))
    (setq custom-file path))
    #+END_SRC
    
    
** shell
*** vars
    #+BEGIN_SRC emacs-lisp :tangle yes
       (defcustom my-shell-program
       	 "/bin/bash"
       	 "Path to shell binary for shell opened by `my-shell-toggle-shell'"
       	 :group 'my-shell)

       (defcustom my-shell-buffer-name-regex
       	 "^\\*term-.*\\*$"
       	 "Regexp used to identify if the current window is a term buffer"
       	 :group 'my-shell)
    #+END_SRC
    
*** funcs
    #+BEGIN_SRC emacs-lisp :tangle yes
       	(defun my-shell-toggle-shell(shell-buffer-name)
       	  "Toggle a window and run program defined in `my-shell-program'
       	If a buffer SHELL-BUFFER-NAME reuse, else start a new term process"
       	  (if (string-match "^\\*term-.*\\*$" (buffer-name))
              (delete-window)
            (select-window (split-window-below))
            (let ((buffer (get-buffer shell-buffer-name)))
              (if buffer
               	  (switch-to-buffer buffer)
               	(term my-shell-program)
               	(rename-buffer shell-buffer-name)))))
    #+END_SRC
    
    #+BEGIN_SRC emacs-lisp :tangle yes
       	(defun my/main-shell ()
       	  "Toggle the main shell"
       	  (interactive)
       	  (my-shell-toggle-shell "*term-main*"))

       	(defun my/buffer-shell ()
       	  "Toggle a buffer local shell"
       	  (interactive)
       	  (my-shell-toggle-shell (concat "*term-" (buffer-name) "*")))

       	(provide 'my-shell)
       	;;; my-shell.el ends here
    #+END_SRC
    
*** keys
    #+BEGIN_SRC emacs-lisp :tangle yes
      (bind-map-set-keys my/base-map
        "'" 'my/main-shell
        "/" 'my/buffer-shell)
    #+END_SRC
* org
** org
   #+BEGIN_SRC emacs-lisp :tangle yes
  (use-package org
    :ensure t
    :config
       (setq org-src-fontify-natively t)
       (setq my/imenu-function 'counsel-org-goto)

      (defun my/org-mode-hooks ()
        (setq my/imenu-function #'counsel-org-goto))
      (add-hook 'org-mode-hook 'my/org-mode-hooks)
      (bind-map-for-major-mode org-mode
        :keys (my/emacs-mode-leader-key)
        :evil-keys (my/evil-mode-leader-key)
        :evil-states (normal motion visual)
        :override-minor-modes t
        :bindings
        ("<tab>" 'org-indent-block
         " RET" 'org-ctrl-c-ret
         "#" 'org-update-statistics-cookies
         "'" 'org-edit-special
         "g" 'org-ctrl-c-star
         "," 'org-ctrl-c-ctrl-c
         "-" 'org-ctrl-c-minus
         "A" 'org-attach
         "H" 'org-shiftleft
         "J" 'org-shiftdown
         "K" 'org-shiftup
         "L" 'org-shiftright
         "a" 'org-agenda
         "c" 'org-capture
         "C-S-h" 'org-shiftcontrolleft
         "C-S-j" 'org-shiftcontroldown
         "C-S-k" 'org-shiftcontrolup
         "C-S-l" 'org-shiftcontrolright
         "x b" 'spacemacs/org-bold
         "x c" 'spacemacs/org-code
         "x i" 'spacemacs/org-italic
         "x o" 'org-open-at-point
         "x r" 'spacemacs/org-clear
         "x s" 'spacemacs/org-strike-through
         "x u" 'spacemacs/org-underline
         "x v" 'spacemacs/org-verbatim
         "i H" 'org-insert-heading-after-current
         "i K" 'spacemacs/insert-keybinding-org
         "i d" 'org-insert-drawer
         "i e" 'org-set-effort
         "i f" 'org-footnote-new
         "i h" 'org-insert-heading
         "i l" 'org-insert-link
         "i n" 'org-add-note
         "i p" 'org-set-property
         "i s" 'org-insert-subheading
         "i t" 'org-set-tags
         "M-RET" 'org-meta-return
         "b ." 'spacemacs/org-babel-transient-state/body
         "b I" 'org-babel-view-src-block-info
         "b Z" 'org-babel-switch-to-session-with-code
         "b a" 'org-babel-sha1-hash
         "b b" 'org-babel-execute-src-block
         "b B" 'org-babel-execute-buffer
         "b c" 'org-babel-check-src-block
         "b d" 'org-babel-demarcate-block
         "b e" 'org-babel-execute-maybe
         "b f" 'org-babel-tangle-file
         "b g" 'org-babel-goto-named-src-block
         "b i" 'org-babel-lob-ingest
         "b j" 'org-babel-insert-header-arg
         "b l" 'org-babel-load-in-session
         "b n" 'org-babel-next-src-block
         "b o" 'org-babel-open-src-block-result
         "b p" 'org-babel-previous-src-block
         "b r" 'org-babel-goto-named-result
         "b s" 'org-babel-execute-subtree
         "b t" 'org-babel-tangle
         "b u" 'org-babel-goto-src-block-head
         "b v" 'org-babel-expand-src-block
         "b x" 'org-babel-do-key-sequence-in-edit-buffer
         "b z" 'org-babel-switch-to-session
         "s A" 'org-archive-subtree
         "s N" 'widen
         "s S" 'org-sort
         "s a" 'org-toggle-archive-tag
         "s b" 'org-tree-to-indirect-buffer
         "s h" 'org-promote-subtree
         "s j" 'org-move-subtree-down
         "s k" 'org-move-subtree-up
         "s l" 'org-demote-subtree
         "s n" 'org-narrow-to-subtree
         "s r" 'org-refile
         "s s" 'org-sparse-tree
         "T T" 'org-todo
         "T V" 'space-doc-mode
         "T c" 'org-toggle-checkbox
         "T e" 'org-toggle-pretty-entities
         "T i" 'org-toggle-inline-images
         "T l" 'org-toggle-link-display
         "T t" 'org-show-todo-tree
         "T x" 'org-toggle-latex-fragment
         "f i" 'org-feed-goto-inbox
         "f u" 'org-feed-update-all
         "e e" 'org-export-dispatch
         "e m" 'org-mime-org-buffer-htmlize
         "d T" 'org-time-stamp-inactive
         "d d" 'org-deadline
         "d s" 'org-schedule
         "d t" 'org-time-stamp
         "C c" 'org-clock-cancel
         "C i" 'org-clock-in
         "C o" 'org-clock-out
         "C p" 'org-pomodoro
         "C r" 'org-resolve-clocks
         "t E" 'org-table-export
         "t H" 'org-table-move-column-left
         "t I" 'org-table-import
         "t J" 'org-table-move-row-down
         "t K" 'org-table-move-row-up
         "t L" 'org-table-move-column-right
         "t N" 'org-table-create-with-table.el
         "t a" 'org-table-align
         "t b" 'org-table-blank-field
         "t c" 'org-table-convert
         "t e" 'org-table-eval-formula
         "t h" 'org-table-previous-field
         "t j" 'org-table-next-row
         "t l" 'org-table-next-field
         "t n" 'org-table-create
         "t p" 'org-plot/gnuplot
         "t r" 'org-table-recalculate
         "t s" 'org-table-sort-lines
         "t w" 'org-table-wrap-region
         "i D s" 'org-download-screenshot
         "i D y" 'org-download-yank
         "t t f" 'org-table-toggle-formula-debugger
         "t t o" 'org-table-toggle-coordinate-overlays
         "t i H" 'org-table-hline-and-move
         "t i c" 'org-table-insert-column
         "t i h" 'org-table-insert-hline
         "t i r" 'org-table-insert-row
         "t d c" 'org-table-delete-column
         "t d r" 'org-table-kill-row)))
    
   #+END_SRC
** org-projectile
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package org-projectile
        :ensure t
        :bind
        (:map
         my/projectile-map
         ("o" . org-projectile/goto-todos)))
    #+END_SRC
** company
    #+BEGIN_SRC emacs-lisp :tangle yes
      (defun my/org-company-setup ()
             (add-to-list 'company-backends 'company-capf)
             (company-mode))
           (add-hook 'org-mode-hook 'my/org-company-setup)
    #+END_SRC
** keys
    #+BEGIN_SRC emacs-lisp :tangle yes
      (bind-map-for-major-mode org-mode
       	:keys (my/emacs-mode-leader-key)
       	:evil-keys (my/evil-mode-leader-key)
       	:evil-states (normal motion visual)
       	:override-minor-modes t
       	:bindings
       	("<tab>" 'org-indent-block
         " RET" 'org-ctrl-c-ret
         "#" 'org-update-statistics-cookies
         "'" 'org-edit-special
         "g" 'org-ctrl-c-star
         "," 'org-ctrl-c-ctrl-c
         "-" 'org-ctrl-c-minus
         "A" 'org-attach
         "H" 'org-shiftleft
         "J" 'org-shiftdown
         "K" 'org-shiftup
         "L" 'org-shiftright
         "a" 'org-agenda
         "c" 'org-capture
         "C-S-h" 'org-shiftcontrolleft
         "C-S-j" 'org-shiftcontroldown
         "C-S-k" 'org-shiftcontrolup
         "C-S-l" 'org-shiftcontrolright
         "x b" 'spacemacs/org-bold
         "x c" 'spacemacs/org-code
         "x i" 'spacemacs/org-italic
         "x o" 'org-open-at-point
         "x r" 'spacemacs/org-clear
         "x s" 'spacemacs/org-strike-through
         "x u" 'spacemacs/org-underline
         "x v" 'spacemacs/org-verbatim
         "i H" 'org-insert-heading-after-current
         "i K" 'spacemacs/insert-keybinding-org
         "i d" 'org-insert-drawer
         "i e" 'org-set-effort
         "i f" 'org-footnote-new
         "i h" 'org-insert-heading
         "i l" 'org-insert-link
         "i n" 'org-add-note
         "i p" 'org-set-property
         "i s" 'org-insert-subheading
         "i t" 'org-set-tags
         "M-RET" 'org-meta-return
         "b ." 'spacemacs/org-babel-transient-state/body
         "b I" 'org-babel-view-src-block-info
         "b Z" 'org-babel-switch-to-session-with-code
         "b a" 'org-babel-sha1-hash
         "b b" 'org-babel-execute-src-block
         "b B" 'org-babel-execute-buffer
         "b c" 'org-babel-check-src-block
         "b d" 'org-babel-demarcate-block
         "b e" 'org-babel-execute-maybe
         "b f" 'org-babel-tangle-file
         "b g" 'org-babel-goto-named-src-block
         "b i" 'org-babel-lob-ingest
         "b j" 'org-babel-insert-header-arg
         "b l" 'org-babel-load-in-session
         "b n" 'org-babel-next-src-block
         "b o" 'org-babel-open-src-block-result
         "b p" 'org-babel-previous-src-block
         "b r" 'org-babel-goto-named-result
         "b s" 'org-babel-execute-subtree
         "b t" 'org-babel-tangle
         "b u" 'org-babel-goto-src-block-head
         "b v" 'org-babel-expand-src-block
         "b x" 'org-babel-do-key-sequence-in-edit-buffer
         "b z" 'org-babel-switch-to-session
         "s A" 'org-archive-subtree
         "s N" 'widen
         "s S" 'org-sort
         "s a" 'org-toggle-archive-tag
         "s b" 'org-tree-to-indirect-buffer
         "s h" 'org-promote-subtree
         "s j" 'org-move-subtree-down
         "s k" 'org-move-subtree-up
         "s l" 'org-demote-subtree
         "s n" 'org-narrow-to-subtree
         "s r" 'org-refile
         "s s" 'org-sparse-tree
         "T T" 'org-todo
         "T V" 'space-doc-mode
         "T c" 'org-toggle-checkbox
         "T e" 'org-toggle-pretty-entities
         "T i" 'org-toggle-inline-images
         "T l" 'org-toggle-link-display
         "T t" 'org-show-todo-tree
         "T x" 'org-toggle-latex-fragment
         "f i" 'org-feed-goto-inbox
         "f u" 'org-feed-update-all
         "e e" 'org-export-dispatch
         "e m" 'org-mime-org-buffer-htmlize
         "d T" 'org-time-stamp-inactive
         "d d" 'org-deadline
         "d s" 'org-schedule
         "d t" 'org-time-stamp
         "C c" 'org-clock-cancel
         "C i" 'org-clock-in
         "C o" 'org-clock-out
         "C p" 'org-pomodoro
         "C r" 'org-resolve-clocks
         "t E" 'org-table-export
         "t H" 'org-table-move-column-left
         "t I" 'org-table-import
         "t J" 'org-table-move-row-down
         "t K" 'org-table-move-row-up
         "t L" 'org-table-move-column-right
         "t N" 'org-table-create-with-table.el
         "t a" 'org-table-align
         "t b" 'org-table-blank-field
         "t c" 'org-table-convert
         "t e" 'org-table-eval-formula
         "t h" 'org-table-previous-field
         "t j" 'org-table-next-row
         "t l" 'org-table-next-field
         "t n" 'org-table-create
         "t p" 'org-plot/gnuplot
         "t r" 'org-table-recalculate
         "t s" 'org-table-sort-lines
         "t w" 'org-table-wrap-region
         "i D s" 'org-download-screenshot
         "i D y" 'org-download-yank
         "t t f" 'org-table-toggle-formula-debugger
         "t t o" 'org-table-toggle-coordinate-overlays
         "t i H" 'org-table-hline-and-move
         "t i c" 'org-table-insert-column
         "t i h" 'org-table-insert-hline
         "t i r" 'org-table-insert-row
         "t d c" 'org-table-delete-column
         "t d r" 'org-table-kill-row))

    #+END_SRC

* prog-mode
** keys
   #+BEGIN_SRC emacs-lisp :tangle yes
     (evil-define-key '(insert normal visual movement) 'prog-mode-map
       (kbd "TAB") 'indent-for-tab-command
       (kbd "M-/") 'hippie-expand)
     (evil-define-key '(normal visual movement) 'prog-mode-map
       (kbd "] e") 'move-text-down
       (kbd "[ e") 'move-text-up)
   #+END_SRC
** hooks
  #+BEGIN_SRC emacs-lisp :tangle yes
    (defun my/prog-mode-hooks ()
      (add-hook 'local-write-file-hook 'my/remove-trailing-whitespace)
      (linum-mode))
    (add-hook 'prog-mode-hook 'my/prog-mode-hooks)
  #+END_SRC
** minior-modes
*** highlight-symbol
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package highlight-symbol
        :ensure t
        :bind
        (:map
         my/search-map
         ("h" . highlight-symbol)
         ("n" . highlight-symbol-nav-mode)
         ("o" . highlight-symbol-occur)
         ("l" . highlight-symbol-list-all)
         ("C" . highlight-symbol-remove-all)
         ("c" . highlight-symbol-remove-all)
         ("r" . highlight-symbol-query-replace))
        :config
        (setq highlight-symbol-color "white")
        (face-spec-set 'highlight-symbol-face
                       '((t :foreground "#eee8d5"))
                       'face-override-spec)
        (add-hook 'prog-mode-hook 'highlight-symbol-mode))
    #+end_src
*** rainbow-delimiters
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package rainbow-delimiters
    :ensure t
    :config
    (add-hook 'prog-mode-hook 'rainbow-delimiters-mode))
#+END_SRC
*** highlight-indent-guides
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package highlight-indentation
        :ensure t
        :config
        (add-hook 'prog-mode-hook 'highlight-indentation-mode))
    #+END_SRC
*** highlight-parentheses
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package highlight-parentheses
        :ensure t
        :config
        (add-hook 'prog-mode-hook 'highlight-parentheses-mode))

    #+END_SRC
*** highlight-changes
    #+BEGIN_SRC emacs-lisp :tangle yes
      (defun my/setup-highlight-changes ()
        (highlight-changes-mode 1)
        (highlight-changes-visible-mode 0)

        (bind-map-set-keys my/help-highlight-map
          "c" 'highlight-changes-visible-mode))
         
      (add-hook 'prog-mode-hook 'my/setup-highlight-changes)
    #+END_SRC
** emacs-lisp-mode
*** macrostep
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package macrostep
        :ensure t)
    #+END_SRC
*** flycheck
   #+BEGIN_SRC emacs-lisp :tangle yes
     (defun my/emacs-lisp-flycheck-setup()
       (add-to-list 'flycheck-disabled-checkers 'emacs-lisp-checkdoc)
       (flycheck-mode))
     (add-hook 'emacs-lisp-mode-hook 'my/emacs-lisp-flycheck-setup)
   #+END_SRC
*** company
   #+BEGIN_SRC emacs-lisp :tangle yes
     (with-eval-after-load 'emacs-lisp-mode
      (add-to-list 'company-backends 'company-elisp))
   #+END_SRC
   #+BEGIN_SRC emacs-lisp :tangle yes
     (defun my-emacs-lisp-company-setup()
      (company-mode 1))
     (add-hook 'emacs-lisp-mode-hook 'my-emacs-lisp-company-setup)
   #+END_SRC
*** keys
**** Hydras
   #+BEGIN_SRC emacs-lisp :tangle yes
   #+END_SRC
**** Evaling
    #+BEGIN_SRC emacs-lisp :tangle yes
      (bind-map elisp-eval-map
        :keys ((my/make-emacs-mode-prefix "e"))
        :evil-keys ((my/make-evil-mode-prefix "e"))
        :major-modes (emacs-lisp-mode)
        :evil-state (normal motion visual)
        :prefix-cmd evaling
        :bindings
        ("f" 'eval-defun
         "$" 'lisp-state-eval-sexp-end-of-line
         "b" 'eval-buffer
         "e" 'eval-last-sexp
         "f" 'eval-defun
         "r" 'eval-region
         ))
    #+end_src
**** Debugging
    #+begin_src emacs-lisp :tangle yes
      (bind-map elisp-debug-map
        :keys ((my/make-emacs-mode-prefix "d"))
        :evil-keys ((my/make-evil-mode-prefix "d"))
        :major-modes (emacs-lisp-mode)
        :evil-state (normal motion visual)
        :prefix-cmd debugging
        :bindings
        ("F" 'spacemacs/edebug-instrument-defun-off
         "f" 'edebug-defun
         "t" 'spacemacs/elisp-toggle-debug-expr-and-eval-func
         "m" 'macrostep-mode))
  #+END_SRC
** c++-mode
*** rtags
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package rtags
        :ensure t
        :config
        (add-to-list 'evil-overriding-maps '(rtags-dependency-tree-mode-map))
        (add-to-list 'evil-overriding-maps '(rtags-references-tree-mode-map)))
    #+END_SRC
**** company-rtags
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package company-rtags
        :ensure t
        :requires (company-mode rtags))
    #+END_SRC
**** flycheck-rtags
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package flycheck-rtags
        :ensure t
        :requires (flycheck-mode rtags))
    #+END_SRC
**** ivy-rtags
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package ivy-rtags
        :ensure t
        :requires (ivy rtags))
    #+END_SRC
**** keys
    #+BEGIN_SRC emacs-lisp :tangle yes
      (bind-map-for-major-mode c++-mode
      :keys (my/emacs-mode-leader-key)
      :evil-keys (my/evil-mode-leader-key)
      :evil-states (normal motion visual)
      :prefix rtags
      :bindings
       ("g g"  'rtags-find-symbol-at-point
        "g G"  'rtags-find-symbol
        "g r"  'rtags-find-references-at-point
        "g R"  'rtags-find-references
        "g F"  'rtags-find-file
        "g v"  'rtags-find-virtuals-at-point
        "g m"  'rtags-find-member-function
        "g l"  'rtags-list-results
        "g c"  'rtags-close-taglist
        "g h"  'rtags-print-class-hierarchy
        "g n"  'rtags-next-match
        "g p"  'rtags-previous-match
        "g f"  'rtags-location-stack-forward
        "g b"    'rtags-location-stack-back
        "g i"    'rtags-symbol-info
        "g e f"  'rtags-fix-fixit-at-point
        "g e F"  'rtags-fixit
        "g e r"  'rtags-rename-symbol
        "g e i"  'rtags-get-include-file-for-symbol
        "g e m"  'rtags-make-member))
    #+END_SRC


   #+BEGIN_SRC emacs-lisp :tangle yes
     (with-eval-after-load 'c++-mode
       (setq rtags-display-result-backend 'ivy)
       (setq rtags-imenu-syntax-highlighting t)
       (setq rtags-autostart-diagnostics t)
       (setq rtags-completions-enabled t)
       (setq rtags-enable-unsaved-reparsing t)
       (my-rtags-keybindings 'c++-mode))
   #+END_SRC
*** flycheck
    #+BEGIN_SRC emacs-lisp :tangle yes
      (defun my/c++-flycheck-setup ()
        (setq flycheck-idle-change-delay 5)
        (flycheck-mode))

      (add-hook 'c++-mode-hook 'my/c++-flycheck-setup)
   #+END_SRC
*** company
   #+BEGIN_SRC emacs-lisp :tangle yes
     (defun my/c++-company-setup ()
       (add-to-list 'company-backends 'company-rtags)
       (company-mode))
     (add-hook 'c++-mode-hook 'my/c++-company-setup)
   #+END_SRC
*** google-c-style
  #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package google-c-style
        :ensure t
        :config
       (add-hook 'c++-mode-hook 'google-set-c-style))
#+END_SRC

*** clang-format
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package clang-format
       	:ensure t
       	:defer t
        :init
       (add-hook 'c++-mode-hook 'my-clang-format-if-file-exists))
    #+end_src
*** funcs
**** my-set-clang-format-hook
    #+begin_src emacs-lisp :tangle yes
      (defun my-set-clang-format-hook () 
        (add-hook 'local-write-file-hooks 'my-clang-format-if-file-exists))
    #+end_src
**** my-remove-clang-format-hook 
    #+begin_src emacs-lisp :tangle yes
      (defun my-remove-clang-format-hook () 
        (remove-hook 'local-write-file-hooks 'my-clang-format-if-file-exists))
    #+end_src
****  my-clang-format-if-file-exists  
    #+begin_src emacs-lisp :tangle yes
      (defun my-clang-format-if-file-exists ()
        (when (eq major-mode 'c++-mode)
          (when (locate-dominating-file (buffer-file-name) ".clang-format")
            (clang-format-buffer))))

    #+END_SRC

* Todos
** TODO ivy resume bindings
** TODO bindings for evil nerd commenter
** TODO fix ivy-occur
** TODO cursor color for state
** TODO modeline
** TODO smartparens
  spc j s sp split sexp
** TODO dumb-jump  
** TODO register keybindings
   
