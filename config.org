* Emacs config

  This is my emcas configuration written in ORG which is tangled by org babel
  during startup.

  Its evil/ivy based and keybindings, package selection and setup is heavily
  inspired by spacemacs but rather than making it ultra modular I've tried to
  keep it as simple as possible focusing on making it easy to debug and quick to
  navigate when adding or disabling stuff on the fly

  The initial sections contain global configuration, package configuration and
  my own set of custom commands.

  The later sections are structured around mode and keymap hierarchies so that
  configuration defined in a section also applies for all subsection. The
  sections are further divided into smaller blocks to make it possible to
  disable packages or configuration while still keeping it bundled with the mode
  it appleies to.

* Initialize package
 We start by adding package repos and load paths and initialize package
   #+BEGIN_SRC emacs-lisp :tangle yes
     (require 'package)
     (add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/") t)
     (add-to-list 'package-archives '("gnu" . "https://elpa.gnu.org/packages/") t)
     (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/") t)
     (let ((default-directory (concat user-emacs-directory "submodules/")))
       (normal-top-level-add-subdirs-to-load-path))
     (add-to-list 'load-path (concat user-emacs-directory "local/"))
     (package-initialize)
#+END_SRC
    Ensure some dependencies are installed. The packages use-package and bind-map are installed, these will be used to
    manage packages and keybindings throughout the config.
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'use-package)
  (dolist (package '(dash use-package bind-map)) nil
    (unless (package-installed-p package)
      (package-refresh-contents)
      (package-install package)))
   #+END_SRC
* Commands and functions
** from spacemacs
   This is a set of functions and commands copied from spacemacs
   mainly used for window and buffer management that i found it hard
   to live .

   this is the original copyright notice
   #+BEGIN_SRC emacs-lisp :tangle yes
     ;;; spacemacs-functions.el --- Library of selected functions taken from spacemacs
     ;;
     ;; Copyright (c) 2012-2017 Sylvain Benner & Contributors
     ;;
     ;; Author: Sylvain Benner <sylvain.benner@gmail.com>
     ;; URL: https://github.com/syl20bnr/spacemacs
     ;;
     ;; This file is not part of GNU Emacs.
     ;;
     ;;; License: GPLv3

     ;; our own implementation of kill-this-buffer from menu-bar.el
   #+END_SRC
   
   #+BEGIN_SRC emacs-lisp :tangle yes
     (defun spacemacs/kill-this-buffer (&optional arg)
       "Kill the current buffer.
     If the universal prefix argument is used then kill also the window."
       (interactive "P")
       (if (window-minibuffer-p)
           (abort-recursive-edit)
         (if (equal '(4) arg)
             (kill-buffer-and-window)
           (kill-buffer))))
   #+end_src
   
   #+begin_src emacs-lisp :tangle yes
     (defun spacemacs/ace-kill-this-buffer (&optional arg)
       "Ace kill visible buffer in a window.
     If the universal prefix argument is used then kill also the window."
       (interactive "P")
       (require 'ace-window)
       (let (golden-ratio-mode)
         (aw-select
          " Ace - Kill buffer in Window"
          (lambda (window)
            (with-selected-window window
              (spacemacs/kill-this-buffer arg))))))
   #+end_src
   
   #+begin_src emacs-lisp :tangle yes
     ;; found at http://emacswiki.org/emacs/KillingBuffers
     (defun spacemacs/kill-other-buffers (&optional arg)
       "Kill all other buffers.
     If the universal prefix argument is used then will the windows too."
       (interactive "P")
       (when (yes-or-no-p (format "Killing all buffers except \"%s\"? "
                                  (buffer-name)))
         (mapc 'kill-buffer (delq (current-buffer) (buffer-list)))
         (when (equal '(4) arg) (delete-other-windows))
         (message "Buffers deleted!")))
   #+end_src
   
   #+begin_src emacs-lisp :tangle yes
     ;; http://camdez.com/blog/2013/11/14/emacs-show-buffer-file-name/
     (defun spacemacs/show-and-copy-buffer-filename ()
       "Show and copy the full path to the current file in the minibuffer."
       (interactive)
       ;; list-buffers-directory is the variable set in dired buffers
       (let ((file-name (or (buffer-file-name) list-buffers-directory)))
         (if file-name
             (message (kill-new file-name))
           (error "Buffer not visiting a file"))))
   #+end_src
   
   #+begin_src emacs-lisp :tangle yes
     (defun spacemacs/new-empty-buffer ()
       "Create a new buffer called untitled(<n>)"
       (interactive)
       (let ((newbuf (generate-new-buffer-name "untitled")))
         (switch-to-buffer newbuf)))
   #+end_src
   
   #+begin_src emacs-lisp :tangle yes
     (defun spacemacs/safe-revert-buffer ()
       "Prompt before reverting the file."
       (interactive)
       (revert-buffer nil nil))
   #+end_src
   
   #+begin_src emacs-lisp :tangle yes
     (defun spacemacs/safe-erase-buffer ()
       "Prompt before erasing the content of the file."
       (interactive)
       (if (y-or-n-p (format "Erase content of buffer %s ? " (current-buffer)))
           (erase-buffer)))
   #+end_src
   
   #+begin_src emacs-lisp :tangle yes
     ;; http://stackoverflow.com/a/10216338/4869
     (defun spacemacs/copy-whole-buffer-to-clipboard ()
       "Copy entire buffer to clipboard"
       (interactive)
       (clipboard-kill-ring-save (point-min) (point-max)))
   #+end_src
   
   #+begin_src emacs-lisp :tangle yes
     (defun spacemacs/copy-clipboard-to-whole-buffer ()
       "Copy clipboard and replace buffer"
       (interactive)
       (delete-region (point-min) (point-max))
       (clipboard-yank)
       (deactivate-mark))
   #+end_src
   
   #+begin_src emacs-lisp :tangle yes
     (defun spacemacs/switch-to-scratch-buffer ()
       "Switch to the `*scratch*' buffer. Create it first if needed."
       (interactive)
       (let ((exists (get-buffer "*scratch*")))
         (switch-to-buffer (get-buffer-create "*scratch*"))
         (when (and (not exists)
                    (not (eq major-mode dotspacemacs-scratch-mode))
                    (fboundp dotspacemacs-scratch-mode))
           (funcall dotspacemacs-scratch-mode))))
   #+end_src
   
   #+begin_src emacs-lisp :tangle yes
     (defun spacemacs/move-buffer-to-window (windownum follow-focus-p)
       "Moves a buffer to a window, using the spacemacs numbering. follow-focus-p
        controls whether focus moves to new window (with buffer), or stays on
        current"
       (interactive)
       (let ((b (current-buffer))
             (w1 (selected-window))
             (w2 (winum-get-window-by-number windownum)))
         (unless (eq w1 w2)
           (set-window-buffer w2 b)
           (switch-to-prev-buffer)
           (unrecord-window-buffer w1 b)))
       (when follow-focus-p (select-window (winum-get-window-by-number windownum))))
   #+end_src
   
   #+begin_src emacs-lisp :tangle yes
     (defun spacemacs/swap-buffers-to-window (windownum follow-focus-p)
       "Swaps visible buffers between active window and selected window.
        follow-focus-p controls whether focus moves to new window (with buffer), or
        stays on current"
       (interactive)
       (let* ((b1 (current-buffer))
              (w1 (selected-window))
              (w2 (winum-get-window-by-number windownum))
              (b2 (window-buffer w2)))
         (unless (eq w1 w2)
           (set-window-buffer w1 b2)
           (set-window-buffer w2 b1)
           (unrecord-window-buffer w1 b1)
           (unrecord-window-buffer w2 b2)))
       (when follow-focus-p (select-window-by-number windownum)))

     (dotimes (i 9)
       (let ((n (+ i 1)))
         (eval `(defun ,(intern (format "buffer-to-window-%s" n)) (&optional arg)
                  ,(format "Move buffer to the window with number %i." n)
                  (interactive "P")
                  (if arg
                      (spacemacs/swap-buffers-to-window ,n t)
                    (spacemacs/move-buffer-to-window ,n t))))
         (eval `(defun ,(intern (format "move-buffer-window-no-follow-%s" n)) ()
                  (interactive)
                  (spacemacs/move-buffer-to-window ,n nil)))
         (eval `(defun ,(intern (format "swap-buffer-window-no-follow-%s" n)) ()
                  (interactive)
                  (spacemacs/swap-buffers-to-window ,n nil)))
         ))
   #+end_src
   
   #+begin_src emacs-lisp :tangle yes
     (defun spacemacs/rotate-windows-backward (count)
       "Rotate each window backwards.
     Dedicated (locked) windows are left untouched."
       (interactive "p")
       (spacemacs/rotate-windows-forward (* -1 count)))
   #+end_src
   
   #+begin_src emacs-lisp :tangle yes
     (defun spacemacs/move-buffer-to-window (windownum follow-focus-p)
       "Moves a buffer to a window, using the spacemacs numbering. follow-focus-p
        controls whether focus moves to new window (with buffer), or stays on
        current"
       (interactive)
       (let ((b (current-buffer))
             (w1 (selected-window))
             (w2 (winum-get-window-by-number windownum)))
         (unless (eq w1 w2)
           (set-window-buffer w2 b)
           (switch-to-prev-buffer)
           (unrecord-window-buffer w1 b)))
       (when follow-focus-p (select-window (winum-get-window-by-number windownum))))
   #+end_src
   
   #+begin_src emacs-lisp :tangle yes
     (defun spacemacs/swap-buffers-to-window (windownum follow-focus-p)
       "Swaps visible buffers between active window and selected window.
        follow-focus-p controls whether focus moves to new window (with buffer), or
        stays on current"
       (interactive)
       (let* ((b1 (current-buffer))
              (w1 (selected-window))
              (w2 (winum-get-window-by-number windownum))
              (b2 (window-buffer w2)))
         (unless (eq w1 w2)
           (set-window-buffer w1 b2)
           (set-window-buffer w2 b1)
           (unrecord-window-buffer w1 b1)
           (unrecord-window-buffer w2 b2)))
       (when follow-focus-p (select-window-by-number windownum)))

     (dotimes (i 9)
       (let ((n (+ i 1)))
         (eval `(defun ,(intern (format "buffer-to-window-%s" n)) (&optional arg)
                  ,(format "Move buffer to the window with number %i." n)
                  (interactive "P")
                  (if arg
                      (spacemacs/swap-buffers-to-window ,n t)
                    (spacemacs/move-buffer-to-window ,n t))))
         (eval `(defun ,(intern (format "move-buffer-window-no-follow-%s" n)) ()
                  (interactive)
                  (spacemacs/move-buffer-to-window ,n nil)))
         (eval `(defun ,(intern (format "swap-buffer-window-no-follow-%s" n)) ()
                  (interactive)
                  (spacemacs/swap-buffers-to-window ,n nil)))
         ))
   #+end_src
   
   #+begin_src emacs-lisp :tangle yes
     (defun spacemacs/delete-window (&optional arg)
       "Delete the current window.
     If the universal prefix argument is used then kill the buffer too."
       (interactive "P")
       (if (equal '(4) arg)
           (kill-buffer-and-window)
         (delete-window)))
   #+end_src
   
   #+begin_src emacs-lisp :tangle yes
     ;; from http://dfan.org/blog/2009/02/19/emacs-dedicated-windows/
     (defun spacemacs/toggle-current-window-dedication ()
       "Toggle dedication state of a window."
       (interactive)
       (let* ((window    (selected-window))
              (dedicated (window-dedicated-p window)))
         (set-window-dedicated-p window (not dedicated))
         (message "Window %sdedicated to %s"
                  (if dedicated "no longer " "")
                  (buffer-name))))
   #+end_src
   
   #+begin_src emacs-lisp :tangle yes
     ;; from https://gist.github.com/timcharper/493269
     (defun spacemacs/split-window-vertically-and-switch ()
       (interactive)
       (split-window-vertically)
       (other-window 1))
   #+end_src
   
   #+begin_src emacs-lisp :tangle yes
     (defun spacemacs/split-window-horizontally-and-switch ()
       (interactive)
       (split-window-horizontally)
       (other-window 1))
   #+end_src
   
   #+begin_src emacs-lisp :tangle yes
     (defun spacemacs/layout-triple-columns ()
       " Set the layout to triple columns. "
       (interactive)
       (delete-other-windows)
       (dotimes (i 2) (split-window-right))
       (balance-windows))
   #+end_src
   
   #+begin_src emacs-lisp :tangle yes
     (defun spacemacs/layout-double-columns ()
       " Set the layout to double columns. "
       (interactive)
       (delete-other-windows)
       (split-window-right))
   #+end_src
   
   #+begin_src emacs-lisp :tangle yes
     (defun spacemacs/toggle-frame-fullscreen ()
       "Respect the `dotspacemacs-fullscreen-use-non-native' variable when
     toggling fullscreen."
       (interactive)
       (if dotspacemacs-fullscreen-use-non-native
           (spacemacs/toggle-frame-fullscreen-non-native)
         (toggle-frame-fullscreen)))
   #+end_src
   
   #+begin_src emacs-lisp :tangle yes
     (defun spacemacs/toggle-fullscreen ()
       "Toggle full screen on X11 and Carbon"
       (interactive)
       (cond
        ((eq window-system 'x)
         (set-frame-parameter nil 'fullscreen
                              (when (not (frame-parameter nil 'fullscreen))
                                'fullboth)))
        ((eq window-system 'mac)
         (set-frame-parameter
          nil 'fullscreen
          (when (not (frame-parameter nil 'fullscreen)) 'fullscreen)))))
   #+end_src
   
   #+begin_src emacs-lisp :tangle yes
     (defun spacemacs/toggle-frame-fullscreen-non-native ()
       "Toggle full screen non-natively. Uses the `fullboth' frame paramerter
        rather than `fullscreen'. Useful to fullscreen on OSX w/o animations."
       (interactive)
       (modify-frame-parameters
        nil
        `((maximized
           . ,(unless (memq (frame-parameter nil 'fullscreen) '(fullscreen fullboth))
                (frame-parameter nil 'fullscreen)))
          (fullscreen
           . ,(if (memq (frame-parameter nil 'fullscreen) '(fullscreen fullboth))
                  (if (eq (frame-parameter nil 'maximized) 'maximized)
                      'maximized)
                'fullboth)))))
   #+end_src
   
   #+begin_src emacs-lisp :tangle yes
     (defun spacemacs/switch-to-minibuffer-window ()
       "switch to minibuffer window (if active)"
       (interactive)
       (when (active-minibuffer-window)
         (select-window (active-minibuffer-window))))
   #+end_src
   
   #+begin_src emacs-lisp :tangle yes
     (defun spacemacs/alternate-buffer (&optional window)
       "Switch back and forth between current and last buffer in the
     current window."
       (interactive)
       (let ((current-buffer (window-buffer window)))
         ;; if no window is found in the windows history, `switch-to-buffer' will
         ;; default to calling `other-buffer'.
         (switch-to-buffer
          (cl-find-if (lambda (buffer)
                        (not (eq buffer current-buffer)))
                      (mapcar #'car (window-prev-buffers window))))))
   #+end_src
   
   #+begin_src emacs-lisp :tangle yes
     ;; from https://gist.github.com/3402786
     (defun spacemacs/toggle-maximize-buffer ()
       "Maximize buffer"
       (interactive)
       (if (and (= 1 (length (window-list)))
                (assoc ?_ register-alist))
           (jump-to-register ?_)
         (progn
           (window-configuration-to-register ?_)
           (delete-other-windows))))
   #+END_SRC
** utility functions
   #+BEGIN_SRC emacs-lisp :tangle yes
     (defun my-read-expanded-filename ()
       "Read a directory with completion and return the expanded filename"
       (expand-file-name
        (read-file-name "dir:" )))
   #+END_SRC
   
   #+BEGIN_SRC emacs-lisp :tangle no
     (defun my/command-wrapper (command)
       "Defines a buffer-local variable named my/COMMAND that calls COMMAND interactively making it possible
       ovverride COMMAND locally by changing the function of my/COMMAND"
(let wrapper ((intern (concat "my" (symbol-name command)) #'command))
       (defvar )
       (interactive)
       (call-interactively my-imenu-function))
   #+END_SRC
** search
   #+BEGIN_SRC emacs-lisp :tangle no
     (defun my-counsel-ack-in-dir (arg)
     "Read directory with completion and call counsel-ack"
       (interactive "P")
       (let ((default-directory (my-read-expanded-filename))
             (initial-input ""))
             (when arg
               (setq initial-input (word-at-point)))
             (counsel-ack "test")))
   #+END_SRC
   
   #+BEGIN_SRC emacs-lisp :tangle no
     (defun my-counesl-grep-in-dir (arg)
       "Read directory with completion and call counsel-grep"
       (interactive"P")
       (let ((default-directory (my-read-expanded-filename)))
         (counsel-grep)))
   #+END_SRC
   
   #+BEGIN_SRC emacs-lisp :tangle no
     (defun my-counsel-ag-in-dir (arg)
     "Read directory with completion and call counsel-grep"
     (let ((default-directory (my-read-expanded-filename)))
       (let ((default-directory (expand-file-name
                               (read-file-name "Starting directory: "))))
       (counsel-grep)))
   #+end_src

   #+begin_src emacs-lisp :tangle no
     (defvar my-imenu-function #'imenu
       "Function called interctively by `my-imenu-or-similar'
       automatically buffer local when set ")

     (defun my-imenu-or-similar ()
       "Call the function defined in `my-imenu-function'"
       (interactive)
       (call-interactively my-imenu-function))

   #+END_SRC
   #+BEGIN_SRC emacs-lisp :tangle no
  (defun my-counsel-git-grep-in-dir ()

    
   #+END_SRC
* Evil
** evil
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package evil
       :ensure t
       :init
       (setq evil-want-integration nil)
       :config
       (evil-mode 1)
       ;; (evil-magit-init)
       )
   #+END_SRC

** evil-collection
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package evil-collection
       :ensure t
       :after evil
       :config
       (evil-collection-init))
   #+END_SRC

** evil-rsi
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package evil-rsi
       :ensure t
       :requires evil)
   #+END_SRC

** evil-iedit-state
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package evil-iedit-state
       :ensure t
       :requires evil iedit)
   #+END_SRC
** evil-escape
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package evil-escape
       :ensure t
       :requires evil
       :config
       (evil-escape-mode 1))
   #+END_SRC

** evil-nerd-commenter
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package evil-nerd-commenter
       :ensure t
       :requires evil)
   #+END_SRC

** evil-surround
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package evil-surround
       :ensure t
           :init
           (add-hook 'after-init-hook 'global-evil-surround-mode)
           :requires evil)
   #+END_SRC

** evil-exchange
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package evil-exchange
       :ensure t
       :requires evil
       :config
       (evil-exchange-cx-install))
   #+END_SRC

** evil-magit
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package evil-magit
       :ensure t
       :init
       :config
       (evil-magit-init))
   #+END_SRC

** evil-unimpaired
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package evil-unimpaired
       :load-path "sumodules/evil-unimpaired"
       :requires evil
       :init
       (add-hook 'evil-mode-hook 'evil-unimpaired-mode))
   #+END_SRC

** evil-rsi
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package evil-rsi
       :ensure t
       :requires evil
       :config (evil-rsi-mode 1))
   #+END_SRC

** org-evil
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package org-evil
        :ensure t
        :requires evil)
   #+END_SRC
* Ivy / counsel
** ivy
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package ivy
    :ensure t
      :bind (:map ivy-minibuffer-map        ; bind in the ivy buffer
           ("" . ivy-alt-done)
           ("C-j" . ivy-next-line)
           ("C-k" . ivy-previous-line)
           ("C-h" . 'ivy-backward-delete-char))
       :init
      (add-hook 'after-init-hook 'ivy-mode)
      :config
      (evil-set-initial-state 'ivy-occur-grep-mode 'normal)
      (evil-make-overriding-map ivy-occur-mode-map 'normal))
#+END_SRC

** ivy-yasnippet
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package ivy-yasnippet
       :ensure t)
   #+END_SRC

** ivy-hydra
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package ivy-hydra
      :ensure t
      :requires (ivy))
  #+END_SRC

** counsel
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package counsel
      :ensure t
      :requires ivy)
  #+END_SRC

** counsel-projectile
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package counsel-projectile
      :ensure t
      :requires (counsel projectile))
  #+END_SRC

* Editing
** iedit
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package iedit 
      :ensure t)
  #+END_SRC
** which-key
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package which-key
      :ensure t
      :init
      (add-hook 'after-init-hook 'which-key-mode))
  #+END_SRC

** move-text
   #+BEGIN_SRC emacs-lisp :tangle yes
  (use-package move-text
    :ensure t
    :init
    (add-hook 'after-init-hook 'which-key-mode))
   #+END_SRC

** undo-tree
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package undo-tree
    :ensure t)
#+END_SRC

** expand-region
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package expand-region
    :ensure t)
#+END_SRC

** evil-multiple-cursors
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package evil-mc
       :ensure t
       :requires evil
       :config
       (evil-mc-mode))
   #+END_SRC
* Completion
** rtags
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package rtags
    :ensure t
    :config
    (add-to-list 'evil-overriding-maps '(rtags-dependency-tree-mode-map))
    (add-to-list 'evil-overriding-maps '(rtags-references-tree-mode-map)))
#+END_SRC



#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package company-rtags
    :ensure t
    :requires (company-mode rtags))
#+END_SRC



#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package flycheck-rtags
    :ensure t
    :requires (flycheck-mode rtags))
#+END_SRC



#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package ivy-rtags
    :ensure t
    :requires (ivy rtags))
#+END_SRC



#+BEGIN_SRC emacs-lisp :tangle yes
  (defun my-rtags-keybindings (major-mode)
   "Set up keybindings for rtags for MAJOR-MODE"
    (eval
     `(bind-map-for-major-mode ,major-mode
     :keys (core-emacs-mode-leader-key)
     :evil-keys (core-evil-mode-leader-key)
     :evil-states (normal motion visual)
     :prefix rtags
     :bindings
      ("g g"  'rtags-find-symbol-at-point
       "g G"  'rtags-find-symbol
       "g r"  'rtags-find-references-at-point
       "g R"  'rtags-find-references
       "g F"  'rtags-find-file
       "g v"  'rtags-find-virtuals-at-point
       "g m"  'rtags-find-member-function
       "g l"  'rtags-list-results
       "g c"  'rtags-close-taglist
       "g h"  'rtags-print-class-hierarchy
       "g n"  'rtags-next-match
       "g p"  'rtags-previous-match
       "g f"  'rtags-location-stack-forward
       "g b"    'rtags-location-stack-back
       "g i"    'rtags-symbol-info
       "g e f"  'rtags-fix-fixit-at-point
       "g e F"  'rtags-fixit
       "g e r"  'rtags-rename-symbol
       "g e i"  'rtags-get-include-file-for-symbol
       "g e m"  'rtags-make-member))))
#+END_SRC


** yasnippet
#+BEGIN_SRC emacs-lisp :tangle yes
    (use-package yasnippet
        :ensure t
        :defer t
        :init
        (add-hook 'prog-mode-hook 'yas-minor-mode)
        (add-hook 'org-mode-hook 'yas-minor-mode)
        :config
        (add-to-list 'hippie-expand-try-functions-list 'yas-hippie-try-expand)
        (yas-reload-all))
    (use-package yasnippet-snippets
        :ensure t
        :requires yasnippet)
#+END_SRC

** flycheck
#+BEGIN_SRC emacs-lisp :tangle yes
       (use-package flycheck
       :ensure t)
#+END_SRC

** company
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package company
       :ensure t
       :config
       (setq company-backends
             '((company-dabbrev-code
                company-gtags
                company-etags
                company-keywords)
               company-files
               company-dabbrev)))
    #+END_SRC

* Navigation
** avy
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package avy
    :ensure t)
#+END_SRC

** grep/ack/wgrep
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package ag
    :ensure t)
#+END_SRC


#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package ack
    :ensure t)
#+END_SRC


#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package wgrep
    :ensure t)
#+END_SRC


#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package wgrep-ack
    :ensure t)
#+END_SRC


#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package wgrep-ag
    :ensure t)
#+END_SRC

* windows and buffers
** winum-mode
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package winum
    :ensure t
    :config
    (winum-mode))
#+END_SRC
* Other packages
** hydra
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package hydra
    :ensure t)
#+END_SRC
** bind-map
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package bind-map
    :ensure t)
#+END_SRC

** magit
#+BEGIN_SRC emacs-lisp :tangle yes
   (use-package magit
   :ensure t)
#+END_SRC
** projectile
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package projectile
    :config
    (add-hook 'after-init-hook 'projectile-mode)
    :ensure t)
#+END_SRC

** company
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package company
       :ensure t
       :config
       (setq company-backends
             '((company-dabbrev-code
                company-gtags
                company-etags
                company-keywords)
               company-files
               company-dabbrev)))
    #+END_SRC

** google-c-style
#+BEGIN_SRC emacs-lisp :tangle yes
      (use-package google-c-style
        :ensure t
        :after c++-mode)
#+END_SRC

** clang-format
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package clang-format
       :ensure t
       :defer t)
   #+END_SRC

* General
** theme
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package solarized-theme
       :config
       (load-theme 'solarized-dark t)
       :ensure t)
   #+END_SRC

** global-minor-modes
   #+BEGIN_SRC emacs-lisp :tangle yes
     (menu-bar-mode 0)
     (tool-bar-mode 0)
     (scroll-bar-mode 0)
     (global-hl-line-mode)
     (setq initial-major-mode 'text-mode)
     (winner-mode 1)
   #+END_SRC

** behaviour
   Keep temporary files to a backup-directory in emacs directory
   #+BEGIN_SRC emacs-lisp :tangle no
     (defvar tramp-backup-directory-alist)
     (defvar tramp-auto-save-directory)
     (let ((backup-dir "~/.emacs.d/.backups")
           (auto-saves-dir "~/.emacs.d/.auto-saves/"))
       (dolist (dir (list backup-dir auto-saves-dir))
         (when (not (file-directory-p dir))
           (make-directory dir t)))
       (setq backup-directory-alist `(("." . ,backup-dir))
             auto-save-file-name-transforms `((".*" ,auto-saves-dir t))
             auto-save-list-file-prefix (concat auto-saves-dir ".saves-")
             tramp-backup-directory-alist `((".*" . ,backup-dir))
             tramp-auto-save-directory auto-saves-dir))
     (setq backup-by-copying t    ; Don't delink hardlinks
           delete-old-versions t  ; Clean up the backups
           version-control t      ; Use version numbers on backups,
           kept-new-versions 5    ; keep some new versions
           kept-old-versions 2)   ; and some old ones, too)
   #+END_SRC

Keep custom variables in a separate gitignored file to allow local customizations
using customize

#+BEGIN_SRC emacs-lisp :tangle yes
  (let ((path (concat user-emacs-directory "custom.el")))
    (unless (file-exists-p path) (write-region "" nil path))
    (setq custom-file path))
#+END_SRC

* Global keybindings
** Variables
   #+BEGIN_SRC emacs-lisp :tangle yes
     (defvar core-evil-leader-key "SPC")
     (defvar core-emacs-leader-key "C-c s")
     (defvar core-evil-mode-leader-key ",")
     (defvar core-emacs-mode-leader-key "C-c ,")
   #+END_SRC

** Functions
   #+BEGIN_SRC emacs-lisp :tangle yes
     (defun core-keys-make-prefix (key)
       (concat core-emacs-leader-key " " key))
     (defun core-keys-make-evil-prefix (key)
       (concat core-evil-leader-key " " key))
     (defun core-keys-make-mode-prefix (key)
       (concat core-emacs-mode-leader-key " " key))
     (defun core-keys-make-evil-mode-prefix (key)
       (concat core-evil-mode-leader-key " " key))
   #+END_SRC

** Evil keys
   #+BEGIN_SRC emacs-lisp :tangle yes
     (evil-define-key '(insert normal visual) 'global-map
       (kbd "M-/") 'hippie-expand)
   #+END_SRC
** Leader map
*** base maps
   #+BEGIN_SRC emacs-lisp :tangle yes
     (bind-map core-base-map
       :keys (core-emacs-leader-key)
       :evil-keys (core-evil-leader-key)
       :evil-states (normal motion visual)
       :override-minor-modes t
       :bindings
       ("0" 'winum-select-window-0-or-10
        "1" 'winum-select-window-1
        "2" 'winum-select-window-2
        "3" 'winum-select-window-3
        "4" 'winum-select-window-4
        "5" 'winum-select-window-5
        "6" 'winum-select-window-6
        "7" 'winum-select-window-7
        "8" 'winum-select-window-8
        "9" 'winum-select-window-9
        "!" 'shell-command
        "v" 'er/expand-region
        ";" 'evilnc-comment-operator
        ":" 'evilnc-comment-and-copy-operator
        "SPC" 'counsel-M-x
        "TAB" 'spacemacs/alternate-buffer
        "u" 'universal-argument
        "d" 'dired
        "'" 'my-shell-toggle-main-shell
        "/" 'my-shell-toggle-buffer-local-shell))
     (bind-map my/mode-leader-map
       :evil-keys (core-evil-mode-leader-key)
       :evil-keys (core-emacs-mode-leader-key)
       :evil-states (normal motion visual)
       :override-minor-modes t)
   #+END_SRC
**** Errors
    #+BEGIN_SRC emacs-lisp :tangle yes
    (bind-map core-errors-map
	  :keys ((core-keys-make-prefix "e"))
	  :evil-keys ((core-keys-make-evil-prefix "e"))
	  :evil-states (normal motion visual)
	  :override-mode-name buffer-keys
	  :prefix-cmd errors
	  :bindings
	  ("n" 'next-error
	  "p" 'previous-error))
 #+END_SRC

**** Buffers
    #+BEGIN_SRC emacs-lisp :tangle yes
      (bind-map core-buffers-map
	:keys ((core-keys-make-prefix "b"))
	:evil-keys ((core-keys-make-evil-prefix "b"))
	:evil-states (normal motion visual)
	:prefix-cmd buffers
	:bindings
	("." 'spacemacs/buffer-transient-state/body
	"1" 'buffer-to-window-1
	"2" 'buffer-to-window-2
	"3" 'buffer-to-window-3
	"4" 'buffer-to-window-4
	"5" 'buffer-to-window-5
	"6" 'buffer-to-window-6
	"7" 'buffer-to-window-7
	"8" 'buffer-to-window-8
	"9" 'buffer-to-window-9
	"B" 'ibuffer
	"N" 'spacemacs/new-empty-buffer
	"P" 'spacemacs/copy-clipboard-to-whole-buffer
	"R" 'spacemacs/safe-revert-buffer
	"Y" 'spacemacs/copy-whole-buffer-to-clipboard
	"b" 'switch-to-buffer
	"d" 'spacemacs/kill-this-buffer
	"e" 'spacemacs/safe-erase-buffer
	"I" 'ibuffer
	"m" 'spacemacs/kill-other-buffers
	"n" 'next-buffer
	"p" 'previous-buffer
	"s" 'spacemacs/switch-to-scratch-buffer
	"w" 'read-only-mode))
    #+END_SRC

**** Windows
    #+BEGIN_SRC emacs-lisp :tangle yes
      (bind-map core-windows-map
        :keys ((core-keys-make-prefix "w"))
        :evil-keys ((core-keys-make-evil-prefix "w"))
        :evil-states (normal motion visual)
        :prefix-cmd windows
        :bindings
        ("w" 'other-window
         "o" 'other-frame
         "s" 'split-window-below
         "S" 'split-window-below-and-focus
         "v" 'split-window-right
         "V" 'split-window-right-and-focus
         "=" 'balance-windows
         "S" 'split-window-below-and-focus
         "V" 'split-window-right-and-focus
         "u" 'winner-undo
         "U" 'winner-redo
         "2" 'spacemacs/layout-double-columns
         "3" 'spacemacs/layout-triple-columns
         "_" 'spacemacs/maximize-horizontally
         "b" 'spacemacs/switch-to-minibuffer-window
         "d" 'spacemacs/delete-window
         "D" 'delete-frame
         "m" 'spacemacs/toggle-maximize-buffer
         "r" 'spacemacs/rotate-windows-forward
         "=" 'balance-windows
         "F" 'make-frame
         "h" 'evil-window-left
         "j" 'evil-window-down
         "k" 'evil-window-up
         "l" 'evil-window-right
         "H" 'evil-window-move-far-left
         "J" 'evil-window-move-very-bottom
         "K" 'evil-window-move-very-top
         "L" 'evil-window-move-far-right
         "<S-down>" 'evil-window-move-very-bottom
         "<S-left>" 'evil-window-move-far-left
         "<S-right>" 'evil-window-move-far-right
         "<S-up>" 'evil-window-move-very-top
         "<down>" 'evil-window-down
         "<left>" 'evil-window-left
         "<right>" 'evil-window-right
         "<up>" 'evil-window-up))
    #+END_SRC

**** Files
    #+BEGIN_SRC emacs-lisp :tangle yes
      (bind-map core-files-map
        :keys ((core-keys-make-prefix "f"))
        :evil-keys ((core-keys-make-evil-prefix "f"))
        :evil-states (normal motion visual)
        :prefix-cmd file
        :bindings
        ("S" 'save-some-buffers
         "b" 'counsel-bookmark
         "g" 'rgrep
         "j" 'dired-jump
         "f" 'find-file
         "l" 'find-file-literally
         "r" 'counsel-recentf
         "s" 'save-buffer
         "y" 'spacemacs/show-and-copy-buffer-filename
         "vd" 'add-dir-local-variable
         "vf" 'add-file-local-variable
         "vp" 'add-file-local-variable-prop-line))
    #+END_SRC

**** Compile/comment
    #+BEGIN_SRC emacs-lisp :tangle yes
      (bind-map core-compile-comment-map
        :keys ((core-keys-make-prefix "c"))
        :evil-keys ((core-keys-make-evil-prefix "c"))
        :evil-states (normal motion visual)
        :prefix-cmd compile-comment
        :bindings
        ("c" 'compile
         "r" 'recompile
         "k" 'kill-compilation
         "l" 'my-comment-or-uncomment-region-or-line))
    #+END_SRC

**** Project
    #+BEGIN_SRC emacs-lisp :tangle yes
      (bind-map core-projectile-map
        :keys ((core-keys-make-prefix "p"))
        :evil-keys ((core-keys-make-evil-prefix "p"))
        :evil-states (normal motion visual)
        :prefix-cmd projectile
        :bindings
        ("SPC" 'counsel-projectile
         "!" 'projectile-run-shell-command-in-root
         "%" 'projectile-replace-regexp
         "&" 'projectile-run-async-shell-command-in-root
         "D" 'projectile-dired
         "F" 'projectile-find-file-dwim
         "G" 'projectile-regenerate-tags
         "I" 'projectile-invalidate-cache
         "R" 'projectile-replace
         "T" 'projectile-test-project
         "a" 'projectile-toggle-between-implementation-and-test
         "b" 'counsel-projectile-switch-to-buffer
         "c" 'projectile-compile-project
         "d" 'counsel-projectile-find-dir
         "e" 'projectile-edit-dir-locals
         "f" 'counsel-projectile-find-file
         "g" 'projectile-find-tag
         "k" 'projectile-kill-buffers
         "l" 'spacemacs/ivy-persp-switch-project
         "o" 'org-projectile/goto-todos
         "p" 'counsel-projectile-switch-project
         "r" 'projectile-recentf
         "v" 'projectile-vc))
    #+END_SRC

**** search
     #+BEGIN_SRC emacs-lisp :tangle yes
       (bind-map core-search-map
         :keys ((core-keys-make-prefix "s"))
         :evil-keys ((core-keys-make-evil-prefix "s"))
         :evil-states (normal motion visual)
         :prefix-cmd searching
         :bindings
         ("s" 'swiper
         "K" 'ack'
         "k" 'counsel-ack
         "g" 'counsel-git-grep
         "G" 'vc-git-grep
         "a" 'counsel-ag
         "A" 'ag
         "e" 'evil-iedit-state/iedit-mode))
     #+END_SRC

**** Git
     #+BEGIN_SRC emacs-lisp :tangle yes
      (bind-map core-git-map
      :keys ((core-keys-make-prefix "g"))
      :evil-keys ((core-keys-make-evil-prefix "g"))
      :evil-states (normal motion visual)
      :prefix-cmd magit
      :bindings
      ("s" 'magit-status
       "A" 'magit-cherry-pick-popup
      "b" 'magit-branch-popup
      "b" 'magit-bisect-popup
      "c" 'magit-commit-popup
      "d" 'magit-diff-popup
      "f" 'magit-fetch-popup
      "F" 'magit-pull-popup
      "l" 'magit-log-popup
      "P" 'magit-pushing-popup
      "r" 'magit-rebase-popup
      "t" magit-tag-popup
      "T" magit-notes-popup
      "_" 'magit-revert-popup
      "O" 'magit-revert-popup
      "z" 'magit-stash-popup
      "!" 'magit-run-popup))
     #+END_SRC

***** git file
  #+BEGIN_SRC emacs-lisp :tangle yes
(bind-map core-magit-file-map
  :keys ((concat core-emacs-leader-key " g f"))
  :evil-keys ((concat core-evil-leader-key " g f"))
  :evil-states (normal motion visual)
  :prefix-cmd git-file
  :bindings
  ("f" 'magit-find-file
  "d" 'magit-diff-buffer-file-popup
  "f" 'magit-find-file
  "l" 'magit-log-buffer-file))
  #+END_SRC

**** Jump/join
     #+BEGIN_SRC emacs-lisp :tangle yes
       (bind-map core-jump-join-map
         :keys ((core-keys-make-prefix "j"))
         :evil-keys ((core-keys-make-evil-prefix "j"))
         :evil-states (normal motion visual)
         :prefix-cmd jump-join
         :bindings
         ("D" 'dired-jump-other-window
          "S" 'spacemacs/split-and-new-line
          "d" 'dired-jump
          "f" 'find-function
          "i" 'imenu
          "o" 'open-line
          "q" 'dumb-jump-quick-look
          "s" 'sp-split-sexp
          "v" 'find-variablef
          "b" 'avy-pop-mark
          "j" 'evil-avy-goto-char-timer
          "l" 'evil-avy-goto-line
          "u" 'spacemacs/avy-goto-url
          "w" 'evil-avy-goto-word-or-subword-1))
     #+END_SRC

**** insert
     #+BEGIN_SRC emacs-lisp :tangle yes
       (bind-map core-insert-map
         :keys ((core-keys-make-prefix "i"))
         :evil-keys ((core-keys-make-evil-prefix "i"))
         :evil-states (normal motion visual)
         :prefix-cmd inserting
         :bindings
         ("y" 'ivy-yasnippet))
     #+END_SRC

****  registers/rings/resume
     #+BEGIN_SRC emacs-lisp :tangle no
       (bind-map core-insert-map
         :keys ((core-keys-make-prefix "i"))
         :evil-keys ((core-keys-make-evil-prefix "i"))
         :evil-states (normal motion visual)
         :prefix-cmd inserting
         :bindings
B 'switch-buffer-without-purpose
D 'purpose-delete-non-dedicated-windows
P 'purpose-set-window-purpose
b 'purpose-switch-buffer-with-purpose
d 'purpose-toggle-window-purpose-dedicated
e 'spacemacs/ivy-evil-registers
l 'ivy-resume
m 'counsel-mark-ring
p 'purpose-switch-buffer-with-some-purpose
y 'counsel-yank-pop

         ("y" 'ivy-yasnippet))

     #+END_SRC
** Prog-mode
   #+BEGIN_SRC emacs-lisp :tangle yes
     (evil-define-key '(normal visual) 'text-mode-map
       ;; (kbd "TAB") 'indent-for-tab-command
         "] e" 'move-text-down
         "[ e" 'move-text-up
         "M-/" 'hippie-expand)
   #+END_SRC

* Org
** variables
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq org-src-fontify-natively t)
   #+END_SRC

** keybindings
   #+BEGIN_SRC emacs-lisp :tangle yes
     (bind-map-for-major-mode org-mode
       :keys (core-emacs-mode-leader-key)
       :evil-keys (core-evil-mode-leader-key)
       :evil-states (normal motion visual)
       :override-minor-modes t
       :bindings
       ("<tab>" 'org-indent-block
        " RET" 'org-ctrl-c-ret
        "#" 'org-update-statistics-cookies
        "'" 'org-edit-special
        "g" 'org-ctrl-c-star
        "," 'org-ctrl-c-ctrl-c
        "-" 'org-ctrl-c-minus
        "A" 'org-attach
        "H" 'org-shiftleft
        "J" 'org-shiftdown
        "K" 'org-shiftup
        "L" 'org-shiftright
        "a" 'org-agenda
        "c" 'org-capture
        "C-S-h" 'org-shiftcontrolleft
        "C-S-j" 'org-shiftcontroldown
        "C-S-k" 'org-shiftcontrolup
        "C-S-l" 'org-shiftcontrolright
        "x b" 'spacemacs/org-bold
        "x c" 'spacemacs/org-code
        "x i" 'spacemacs/org-italic
        "x o" 'org-open-at-point
        "x r" 'spacemacs/org-clear
        "x s" 'spacemacs/org-strike-through
        "x u" 'spacemacs/org-underline
        "x v" 'spacemacs/org-verbatim
        "i H" 'org-insert-heading-after-current
        "i K" 'spacemacs/insert-keybinding-org
        "i d" 'org-insert-drawer
        "i e" 'org-set-effort
        "i f" 'org-footnote-new
        "i h" 'org-insert-heading
        "i l" 'org-insert-link
        "i n" 'org-add-note
        "i p" 'org-set-property
        "i s" 'org-insert-subheading
        "i t" 'org-set-tags
        "M-RET" 'org-meta-return
        "b ." 'spacemacs/org-babel-transient-state/body
        "b I" 'org-babel-view-src-block-info
        "b Z" 'org-babel-switch-to-session-with-code
        "b a" 'org-babel-sha1-hash
        "b b" 'org-babel-execute-src-block
        "b B" 'org-babel-execute-buffer
        "b c" 'org-babel-check-src-block
        "b d" 'org-babel-demarcate-block
        "b e" 'org-babel-execute-maybe
        "b f" 'org-babel-tangle-file
        "b g" 'org-babel-goto-named-src-block
        "b i" 'org-babel-lob-ingest
        "b j" 'org-babel-insert-header-arg
        "b l" 'org-babel-load-in-session
        "b n" 'org-babel-next-src-block
        "b o" 'org-babel-open-src-block-result
        "b p" 'org-babel-previous-src-block
        "b r" 'org-babel-goto-named-result
        "b s" 'org-babel-execute-subtree
        "b t" 'org-babel-tangle
        "b u" 'org-babel-goto-src-block-head
        "b v" 'org-babel-expand-src-block
        "b x" 'org-babel-do-key-sequence-in-edit-buffer
        "b z" 'org-babel-switch-to-session
        "s A" 'org-archive-subtree
        "s N" 'widen
        "s S" 'org-sort
        "s a" 'org-toggle-archive-tag
        "s b" 'org-tree-to-indirect-buffer
        "s h" 'org-promote-subtree
        "s j" 'org-move-subtree-down
        "s k" 'org-move-subtree-up
        "s l" 'org-demote-subtree
        "s n" 'org-narrow-to-subtree
        "s r" 'org-refile
        "s s" 'org-sparse-tree
        "T T" 'org-todo
        "T V" 'space-doc-mode
        "T c" 'org-toggle-checkbox
        "T e" 'org-toggle-pretty-entities
        "T i" 'org-toggle-inline-images
        "T l" 'org-toggle-link-display
        "T t" 'org-show-todo-tree
        "T x" 'org-toggle-latex-fragment
        "f i" 'org-feed-goto-inbox
        "f u" 'org-feed-update-all
        "e e" 'org-export-dispatch
        "e m" 'org-mime-org-buffer-htmlize
        "d T" 'org-time-stamp-inactive
        "d d" 'org-deadline
        "d s" 'org-schedule
        "d t" 'org-time-stamp
        "C c" 'org-clock-cancel
        "C i" 'org-clock-in
        "C o" 'org-clock-out
        "C p" 'org-pomodoro
        "C r" 'org-resolve-clocks
        "t E" 'org-table-export
        "t H" 'org-table-move-column-left
        "t I" 'org-table-import
        "t J" 'org-table-move-row-down
        "t K" 'org-table-move-row-up
        "t L" 'org-table-move-column-right
        "t N" 'org-table-create-with-table.el
        "t a" 'org-table-align
        "t b" 'org-table-blank-field
        "t c" 'org-table-convert
        "t e" 'org-table-eval-formula
        "t h" 'org-table-previous-field
        "t j" 'org-table-next-row
        "t l" 'org-table-next-field
        "t n" 'org-table-create
        "t p" 'org-plot/gnuplot
        "t r" 'org-table-recalculate
        "t s" 'org-table-sort-lines
        "t w" 'org-table-wrap-region
        "i D s" 'org-download-screenshot
        "i D y" 'org-download-yank
        "t t f" 'org-table-toggle-formula-debugger
        "t t o" 'org-table-toggle-coordinate-overlays
        "t i H" 'org-table-hline-and-move
        "t i c" 'org-table-insert-column
        "t i h" 'org-table-insert-hline
        "t i r" 'org-table-insert-row
        "t d c" 'org-table-delete-column
        "t d r" 'org-table-kill-row))

   #+END_SRC

* Shell
** Variables
   #+BEGIN_SRC emacs-lisp :tangle yes
     (defcustom my-shell-program
       "/bin/bash"
       "Path to shell binary for shell opened by `my-shell-toggle-shell'"
       :group 'my-shell)

     (defcustom my-shell-buffer-name-regex
       "^\\*term-.*\\*$"
       "Regexp used to identify if the current window is a term buffer"
       :group 'my-shell)
   #+END_SRC

** Functions
   #+BEGIN_SRC emacs-lisp :tangle yes

   (defun my-shell-toggle-shell(shell-buffer-name)
   "Toggle a window and run program defined in `my-shell-program'
   If a buffer SHELL-BUFFER-NAME reuse, else start a new term process"
   (if (string-match "^\\*term-.*\\*$" (buffer-name))
   (delete-window)
   (select-window (split-window-below))
   (let ((buffer (get-buffer shell-buffer-name)))
   (if buffer
   (switch-to-buffer buffer)
   (term my-shell-program)
   (rename-buffer shell-buffer-name)))))
   #+END_SRC

** Commands
   #+BEGIN_SRC emacs-lisp :tangle yes
     (defun my-shell-toggle-main-shell ()
       "Toggle the main shell"
       (interactive)
       (my-shell-toggle-shell "*term-main*"))

     (defun my-shell-toggle-buffer-local-shell ()
       "Toggle a buffer local shell"
       (interactive)
       (my-shell-toggle-shell (concat "*term-" (buffer-name) "*")))

     (provide 'my-shell)
     ;;; my-shell.el ends here
   #+END_SRC

* prog-mode
** keybindings
   #+BEGIN_SRC emacs-lisp :tangle yes
     (evil-define-key '(insert normal visual movement) 'global-map
       (kbd "TAB") 'indent-for-tab-command
       (kbd "M-/") 'hippie-expand)
   #+END_SRC
** emacs-lisp-mode
*** macrostep
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package macrostep
        :ensure t)
    #+END_SRC
*** flycheck
   #+BEGIN_SRC emacs-lisp :tangle yes
     (with-eval-after-load 'emacs-lisp-mode
       (defun my/emacs-lisp-flycheck-mode-setup()
         (add-to-list 'flycheck-disabled-checkers 'emacs-lisp-checkdoc)
         (flycheck-mode 1))
       (add-hook 'emacs-lisp-mode-hook 'my/emacs-lisp-flycheck-mode-setup))

   #+END_SRC
*** company
   #+BEGIN_SRC emacs-lisp :tangle yes
     (with-eval-after-load 'emacs-lisp-mode
      (add-to-list 'company-backends 'company-elisp))
   #+END_SRC

     (defun my-emacs-lisp-mode-hooks()
      (company-mode 1)
     (add-hook 'emacs-lisp-mode-hook 'my-emacs-lisp-mode-hooks)
   #+END_SRC
*** keybindings 
**** Hydras
   #+BEGIN_SRC emacs-lisp :tangle yes
   #+END_SRC
**** Evaling
    #+BEGIN_SRC emacs-lisp :tangle yes
      (bind-map elisp-eval-map
        :keys ((core-keys-make-mode-prefix "e"))
        :evil-keys ((core-keys-make-evil-mode-prefix "e"))
        :major-modes (emacs-lisp-mode)
        :evil-state (normal motion visual)
        :prefix-cmd evaling
        :bindings 
        ("f" 'eval-defun
         "$" 'lisp-state-eval-sexp-end-of-line
         "b" 'eval-buffer
         "e" 'eval-last-sexp
         "f" 'eval-defun
         "r" 'eval-region
         ))
    #+end_src
**** Debugging 
    #+begin_src emacs-lisp :tangle yes
      (bind-map elisp-debug-map
        :keys ((core-keys-make-mode-prefix "d"))
        :evil-keys ((core-keys-make-evil-mode-prefix "d"))
        :major-modes (emacs-lisp-mode)
        :evil-state (normal motion visual)
        :prefix-cmd debugging
        :bindings 
        ("F" 'spacemacs/edebug-instrument-defun-off
         "f" 'edebug-defun
         "t" 'spacemacs/elisp-toggle-debug-expr-and-eval-func
         "m" 'macrostep-mode))
  #+END_SRC
** c++-mode
*** rtags
   #+BEGIN_SRC emacs-lisp :tangle yes
     (with-eval-after-load 'c++-mode
       (setq rtags-display-result-backend 'ivy)
       (setq rtags-imenu-syntax-highlighting t)
       (setq rtags-autostart-diagnostics t)
       (setq rtags-completions-enabled t)
       (setq rtags-enable-unsaved-reparsing t)
       (my-rtags-keybindings 'c++-mode))
   #+END_SRC
*** flycheck
    #+BEGIN_SRC emacs-lisp :tangle yes
     (with-eval-after-load 'c++-mode
       (setq flycheck-idle-change-delay 5)
       (add-hook 'c++-mode-hook 'flycheck-mode))
   #+END_SRC
*** company
   #+BEGIN_SRC emacs-lisp :tangle yes
     (with-eval-after-load 'c++-mode
       (add-hook 'c++-mode-hook 'company-mode)
       (add-to-list 'company-backends 'company-rtags))
   #+END_SRC
*** clang-format
   #+BEGIN_SRC emacs-lisp :tangle yes
     (with-eval-after-load 'c++-mode
       (defun my-clang-format-if-file-exists ()
         (when (eq major-mode 'c++-mode)
           (when (locate-dominating-file (buffer-file-name) ".clang-format")
             (clang-format-buffer))))
       (add-hook 'before-save-hook 'my-clang-format-if-file-exists))
   #+END_SRC
*** google-c-style
    #+BEGIN_SRC emacs-lisp :tangle yes
      (with-eval-after-load 'c++-mode
        (add-hook 'c++-mode-hook 'google-set-c-style))
    #+END_SRC

* Todos
** TODO ivy resume bindings
** TODO bindings for evil nerd commenter
** TODO fix ivy-occur
