* Emacs config

  This is my emcas configuration written in ORG which is tangled by org babel
  during startup.

  Its evil/ivy based and keybindings, package selection and setup is heavily
  inspired by spacapplies for all subsection. The
  sections are further divided into smaller blocks to make it possible to
  disable packages or configuration while still keeping it bundled with the mode
  it appleies to.

* general config
   Balance windows automatically
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq window-combination-resize t)
   #+END_SRC

   Global minor modes
   #+BEGIN_SRC emacs-lisp :tangle yes
    (menu-bar-mode 0)
    (tool-bar-mode 0)
    (scroll-bar-mode 0)
    (global-hl-line-mode)
    (setq initial-major-mode 'text-mode)
    (winner-mode 1)
   #+END_SRC

   Keep temporary files to a backup-directory in emacs directory
   #+BEGIN_SRC emacs-lisp :tangle no
    (defvar tramp-backup-directory-alist)
    (defvar tramp-auto-save-directory)
    (let ((backup-dir "~/.emacs.d/.backups")
	  (auto-saves-dir "~/.emacs.d/.auto-saves/"))
      (dolist (dir (list backup-dir auto-saves-dir))
	(when (not (file-directory-p dir))
	  (make-directory dir t)))
      (setq backup-directory-alist `(("." . ,backup-dir))
	    auto-save-file-name-transforms `((".*" ,auto-saves-dir t))
	    auto-save-list-file-prefix (concat auto-saves-dir ".saves-")
	    tramp-backup-directory-alist `((".*" . ,backup-dir))
	    tramp-auto-save-directory auto-saves-dir))
    (setq backup-by-copying t    ; Don't delink hardlinks
	  delete-old-versions t  ; Clean up the backups
	  version-control t      ; Use version numbers on backups,
	  kept-new-versions 5    ; keep some new versions
	  kept-old-versions 2)   ; and some old ones, too)
   #+END_SRC

   Keep custom variables in a separate gitignored file to allow local customizations
   using customize
   #+BEGIN_SRC emacs-lisp :tangle yes
 (let ((path (concat user-emacs-directory "custom.el")))
   (unless (file-exists-p path) (write-region "" nil path))
   (setq custom-file path))
   #+END_SRC
   Speed up tramp
   #+BEGIN_SRC emacs-lisp :tangle yes
   (setq tramp-default-method "ssh")
   #+END_SRC

* initialize package
 We start by adding package repos and load paths and initialize package
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'package)
  (add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/") t)
  (add-to-list 'package-archives '("gnu" . "https://elpa.gnu.org/packages/") t)
  (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/") t)
  (let ((default-directory (concat user-emacs-directory "submodules/")))
    (normal-top-level-add-subdirs-to-load-path))
  (add-to-list 'load-path (concat user-emacs-directory "packages/"))
  (package-initialize)
#+END_SRC
    Ensure some important dependencies are installed. The packages use-package and bind-map will be used to
    manage packages and keybindings throughout the config.
#+BEGIN_SRC emacs-lisp :tangle yes
  (dolist (package '(dash use-package bind-map hydra)) nil
    (unless (package-installed-p package)
      (package-refresh-contents)
      (package-install package)))
  (require 'use-package)
  (require 'bind-map)
   #+END_SRC
* theme
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package solarized-theme
       :config
       (load-theme 'solarized-dark t)
       :ensure t)
   #+END_SRC
* mode-line
  #+BEGIN_SRC emacs-lisp :tangle yes
    (defun my/setup-mode-line ()
      (setq mode-line-format '("%e"
			       (:eval
				(winum-get-number-string))
			       mode-line-front-space
			       mode-line-mule-info
			       mode-line-client
			       mode-line-modified
			       mode-line-remote
			       mode-line-frame-identification
			       mode-line-buffer-identification
			       "   "
			       mode-line-position
			       evil-mode-line-tag
			       (vc-mode vc-mode)
			       "  " mode-line-misc-info
			       mode-line-end-spaces)))

    (add-hook 'after-change-major-mode-hook 'my/setup-mode-line)
  #+END_SRC
* utility functions
  #+BEGIN_SRC emacs-lisp :tangle yes
    (defun my/-set-font-size-globally ()
      (interactive)
      (set-face-attribute 'default nil :height (string-to-int (read-from-minibuffer "font size: "))))
  #+END_SRC
  #+BEGIN_SRC emacs-lisp :tangle yes
     (defun my-read-expanded-filename ()
       "Read a directory with completion and return the expanded filename"
       (expand-file-name
	(read-file-name "dir:" )))
  #+END_SRC
  #+BEGIN_SRC emacs-lisp :tangle yes
    (defun my/make-emacs-prefix (key)
      (concat my/emacs-leader-key " " key))
    (defun my/make-evil-prefix (key)
      (concat my/evil-leader-key " " key))
    (defun my/make-emacs-mode-prefix (key)
      (concat my/emacs-mode-leader-key " " key))
    (defun my/make-evil-mode-prefix (key)
      (concat my/evil-mode-leader-key " " key))
  #+END_SRC
  #+BEGIN_SRC emacs-lisp :tangle yes
    (defun my/delete-frame-with-prompt ()
      (interactive)
      (when (y-or-n-p "Really delete frame?")
      (delete-frame)))
  #+END_SRC
* search commands
   #+BEGIN_SRC emacs-lisp :tangle yes
     (defun my-counsel-ack-in-dir (arg)
     "Read directory with completion and call counsel-ack"
       (interactive "P")
       (let ((default-directory (my-read-expanded-filename))
	     (initial-input ""))
	     (when arg
	       (setq initial-input (word-at-point)))
	     (counsel-ack initial-input)))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp :tangle no
     (defun my-counsel-git-grep-in-dir ()
       (interactive)
       (let ((path (my-read-expanded-filename)))
	 (counsel-git-grep nil (concat " -- " path " ")))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp :tangle no
     (defun my-counesl-grep-in-dir (arg)
       "Read directory with completion and call counsel-grep"
       (interactive"P")
       (let ((default-directory (my-read-expanded-filename)))
	 (counsel-grep)))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp :tangle no
     (defun my-counsel-ag-in-dir (arg)
     "Read directory with completion and call counsel-grep"
     (let ((default-directory (my-read-expanded-filename)))
       (let ((default-directory (expand-file-name
			       (read-file-name "Starting directory: "))))
       (counsel-grep)))
   #+end_src

   #+begin_src emacs-lisp :tangle no
     (defvar my-imenu-function #'imenu
       "Function called interctively by `my-imenu-or-similar'
       automatically buffer local when set ")

     (defun my-imenu-or-similar ()
       "Call the function defined in `my-imenu-function'"
       (interactive)
       (call-interactively my-imenu-function))

   #+END_SRC
   #+BEGIN_SRC emacs-lisp :tangle no
  (defun my-counsel-git-grep-in-dir ()


   #+END_SRC
* editing
   #+BEGIN_SRC emacs-lisp :tangle yes
     (defun my/remove-trailing-whitespace ()
       (interactive)
       (save-excursion
	 (goto-char (point-min))
	 (while (re-search-forward "[ \t]+$" nil t)
	   (replace-match "" nil nil)))
       nil)
   #+END_SRC
* command wrappers
  #+BEGIN_SRC emacs-lisp :tangle yes
    (defun my/imenu ()
      "Call the function `my/imenu-function' interactively"
      (interactive)
      (call-interactively my/imenu-function))
  #+END_SRC
* from spacemacs
   This is a set of functions and commands copied from spacemacs
   mainly used for window and buffer management that i found it hard
   to live .

   this is the original copyright notice
   #+BEGIN_SRC emacs-lisp :tangle yes
     ;;; spacemacs-functions.el --- Library of selected functions taken from spacemacs
     ;;
     ;; Copyright (c) 2012-2017 Sylvain Benner & Contributors
     ;;
     ;; Author: Sylvain Benner <sylvain.benner@gmail.com>
     ;; URL: https://github.com/syl20bnr/spacemacs
     ;;
     ;; This file is not part of GNU Emacs.
     ;;
     ;;; License: GPLv3

     ;; our own implementation of kill-this-buffer from menu-bar.el
   #+END_SRC

   #+BEGIN_SRC emacs-lisp :tangle yes
     (defun spacemacs/kill-this-buffer (&optional arg)
       "Kill the current buffer.
     If the universal prefix argument is used then kill also the window."
       (interactive "P")
       (if (window-minibuffer-p)
	   (abort-recursive-edit)
	 (if (equal '(4) arg)
	     (kill-buffer-and-window)
	   (kill-buffer))))
   #+end_src

   #+begin_src emacs-lisp :tangle yes
     (defun spacemacs/ace-kill-this-buffer (&optional arg)
       "Ace kill visible buffer in a window.
     If the universal prefix argument is used then kill also the window."
       (interactive "P")
       (require 'ace-window)
       (let (golden-ratio-mode)
	 (aw-select
	  " Ace - Kill buffer in Window"
	  (lambda (window)
	    (with-selected-window window
	      (spacemacs/kill-this-buffer arg))))))
   #+end_src

   #+begin_src emacs-lisp :tangle yes
     ;; found at http://emacswiki.org/emacs/KillingBuffers
     (defun spacemacs/kill-other-buffers (&optional arg)
       "Kill all other buffers.
     If the universal prefix argument is used then will the windows too."
       (interactive "P")
       (when (yes-or-no-p (format "Killing all buffers except \"%s\"? "
				  (buffer-name)))
	 (mapc 'kill-buffer (delq (current-buffer) (buffer-list)))
	 (when (equal '(4) arg) (delete-other-windows))
	 (message "Buffers deleted!")))
   #+end_src

   #+begin_src emacs-lisp :tangle yes
     ;; http://camdez.com/blog/2013/11/14/emacs-show-buffer-file-name/
     (defun spacemacs/show-and-copy-buffer-filename ()
       "Show and copy the full path to the current file in the minibuffer."
       (interactive)
       ;; list-buffers-directory is the variable set in dired buffers
       (let ((file-name (or (buffer-file-name) list-buffers-directory)))
	 (if file-name
	     (message (kill-new file-name))
	   (error "Buffer not visiting a file"))))
   #+end_src

   #+begin_src emacs-lisp :tangle yes
     (defun spacemacs/new-empty-buffer ()
       "Create a new buffer called untitled(<n>)"
       (interactive)
       (let ((newbuf (generate-new-buffer-name "untitled")))
	 (switch-to-buffer newbuf)))
   #+end_src

   #+begin_src emacs-lisp :tangle yes
     (defun spacemacs/safe-revert-buffer ()
       "Prompt before reverting the file."
       (interactive)
       (revert-buffer nil nil))
   #+end_src

   #+begin_src emacs-lisp :tangle yes
     (defun spacemacs/safe-erase-buffer ()
       "Prompt before erasing the content of the file."
       (interactive)
       (if (y-or-n-p (format "Erase content of buffer %s ? " (current-buffer)))
	   (erase-buffer)))
   #+end_src

   #+begin_src emacs-lisp :tangle yes
     ;; http://stackoverflow.com/a/10216338/4869
     (defun spacemacs/copy-whole-buffer-to-clipboard ()
       "Copy entire buffer to clipboard"
       (interactive)
       (clipboard-kill-ring-save (point-min) (point-max)))
   #+end_src

   #+begin_src emacs-lisp :tangle yes
     (defun spacemacs/copy-clipboard-to-whole-buffer ()
       "Copy clipboard and replace buffer"
       (interactive)
       (delete-region (point-min) (point-max))
       (clipboard-yank)
       (deactivate-mark))
   #+end_src

   #+begin_src emacs-lisp :tangle yes
     (defun spacemacs/switch-to-scratch-buffer ()
       "Switch to the `*scratch*' buffer. Create it first if needed."
       (interactive)
       (let ((exists (get-buffer "*scratch*")))
	 (switch-to-buffer (get-buffer-create "*scratch*"))
	 (when (and (not exists)
		    (not (eq major-mode dotspacemacs-scratch-mode))
		    (fboundp dotspacemacs-scratch-mode))
	   (funcall dotspacemacs-scratch-mode))))
   #+end_src

   #+begin_src emacs-lisp :tangle yes
     (defun spacemacs/move-buffer-to-window (windownum follow-focus-p)
       "Moves a buffer to a window, using the spacemacs numbering. follow-focus-p
	controls whether focus moves to new window (with buffer), or stays on
	current"
       (interactive)
       (let ((b (current-buffer))
	     (w1 (selected-window))
	     (w2 (winum-get-window-by-number windownum)))
	 (unless (eq w1 w2)
	   (set-window-buffer w2 b)
	   (switch-to-prev-buffer)
	   (unrecord-window-buffer w1 b)))
       (when follow-focus-p (select-window (winum-get-window-by-number windownum))))
   #+end_src

   #+begin_src emacs-lisp :tangle yes
     (defun spacemacs/swap-buffers-to-window (windownum follow-focus-p)
       "Swaps visible buffers between active window and selected window.
	follow-focus-p controls whether focus moves to new window (with buffer), or
	stays on current"
       (interactive)
       (let* ((b1 (current-buffer))
	      (w1 (selected-window))
	      (w2 (winum-get-window-by-number windownum))
	      (b2 (window-buffer w2)))
	 (unless (eq w1 w2)
	   (set-window-buffer w1 b2)
	   (set-window-buffer w2 b1)
	   (unrecord-window-buffer w1 b1)
	   (unrecord-window-buffer w2 b2)))
       (when follow-focus-p (select-window-by-number windownum)))

     (dotimes (i 9)
       (let ((n (+ i 1)))
	 (eval `(defun ,(intern (format "buffer-to-window-%s" n)) (&optional arg)
		  ,(format "Move buffer to the window with number %i." n)
		  (interactive "P")
		  (if arg
		      (spacemacs/swap-buffers-to-window ,n t)
		    (spacemacs/move-buffer-to-window ,n t))))
	 (eval `(defun ,(intern (format "move-buffer-window-no-follow-%s" n)) ()
		  (interactive)
		  (spacemacs/move-buffer-to-window ,n nil)))
	 (eval `(defun ,(intern (format "swap-buffer-window-no-follow-%s" n)) ()
		  (interactive)
		  (spacemacs/swap-buffers-to-window ,n nil)))
	 ))
   #+end_src

   #+begin_src emacs-lisp :tangle yes
     (defun spacemacs/rotate-windows-backward (count)
       "Rotate each window backwards.
     Dedicated (locked) windows are left untouched."
       (interactive "p")
       (spacemacs/rotate-windows-forward (* -1 count)))
   #+end_src

   #+begin_src emacs-lisp :tangle yes
     (defun spacemacs/move-buffer-to-window (windownum follow-focus-p)
       "Moves a buffer to a window, using the spacemacs numbering. follow-focus-p
	controls whether focus moves to new window (with buffer), or stays on
	current"
       (interactive)
       (let ((b (current-buffer))
	     (w1 (selected-window))
	     (w2 (winum-get-window-by-number windownum)))
	 (unless (eq w1 w2)
	   (set-window-buffer w2 b)
	   (switch-to-prev-buffer)
	   (unrecord-window-buffer w1 b)))
       (when follow-focus-p (select-window (winum-get-window-by-number windownum))))
   #+end_src

   #+begin_src emacs-lisp :tangle yes
     (defun spacemacs/swap-buffers-to-window (windownum follow-focus-p)
       "Swaps visible buffers between active window and selected window.
	follow-focus-p controls whether focus moves to new window (with buffer), or
	stays on current"
       (interactive)
       (let* ((b1 (current-buffer))
	      (w1 (selected-window))
	      (w2 (winum-get-window-by-number windownum))
	      (b2 (window-buffer w2)))
	 (unless (eq w1 w2)
	   (set-window-buffer w1 b2)
	   (set-window-buffer w2 b1)
	   (unrecord-window-buffer w1 b1)
	   (unrecord-window-buffer w2 b2)))
       (when follow-focus-p (select-window-by-number windownum)))

     (dotimes (i 9)
       (let ((n (+ i 1)))
	 (eval `(defun ,(intern (format "buffer-to-window-%s" n)) (&optional arg)
		  ,(format "Move buffer to the window with number %i." n)
		  (interactive "P")
		  (if arg
		      (spacemacs/swap-buffers-to-window ,n t)
		    (spacemacs/move-buffer-to-window ,n t))))
	 (eval `(defun ,(intern (format "move-buffer-window-no-follow-%s" n)) ()
		  (interactive)
		  (spacemacs/move-buffer-to-window ,n nil)))
	 (eval `(defun ,(intern (format "swap-buffer-window-no-follow-%s" n)) ()
		  (interactive)
		  (spacemacs/swap-buffers-to-window ,n nil)))
	 ))
   #+end_src

   #+begin_src emacs-lisp :tangle yes
     (defun spacemacs/delete-window (&optional arg)
       "Delete the current window.
     If the universal prefix argument is used then kill the buffer too."
       (interactive "P")
       (if (equal '(4) arg)
	   (kill-buffer-and-window)
	 (delete-window)))
   #+end_src

   #+begin_src emacs-lisp :tangle yes
     ;; from http://dfan.org/blog/2009/02/19/emacs-dedicated-windows/
     (defun spacemacs/toggle-current-window-dedication ()
       "Toggle dedication state of a window."
       (interactive)
       (let* ((window    (selected-window))
	      (dedicated (window-dedicated-p window)))
	 (set-window-dedicated-p window (not dedicated))
	 (message "Window %sdedicated to %s"
		  (if dedicated "no longer " "")
		  (buffer-name))))
   #+end_src

   #+begin_src emacs-lisp :tangle yes
     ;; from https://gist.github.com/timcharper/493269
     (defun spacemacs/split-window-vertically-and-switch ()
       (interactive)
       (split-window-vertically)
       (other-window 1))
   #+end_src

   #+begin_src emacs-lisp :tangle yes
     (defun spacemacs/split-window-horizontally-and-switch ()
       (interactive)
       (split-window-horizontally)
       (other-window 1))
   #+end_src

   #+begin_src emacs-lisp :tangle yes
     (defun spacemacs/layout-triple-columns ()
       " Set the layout to triple columns. "
       (interactive)
       (delete-other-windows)
       (dotimes (i 2) (split-window-right))
       (balance-windows))
   #+end_src

   #+begin_src emacs-lisp :tangle yes
     (defun spacemacs/layout-double-columns ()
       " Set the layout to double columns. "
       (interactive)
       (delete-other-windows)
       (split-window-right))
   #+end_src

   #+begin_src emacs-lisp :tangle yes
     (defun spacemacs/toggle-frame-fullscreen ()
       "Respect the `dotspacemacs-fullscreen-use-non-native' variable when
     toggling fullscreen."
       (interactive)
       (if dotspacemacs-fullscreen-use-non-native
	   (spacemacs/toggle-frame-fullscreen-non-native)
	 (toggle-frame-fullscreen)))
   #+end_src

   #+begin_src emacs-lisp :tangle yes
     (defun spacemacs/toggle-fullscreen ()
       "Toggle full screen on X11 and Carbon"
       (interactive)
       (cond
	((eq window-system 'x)
	 (set-frame-parameter nil 'fullscreen
			      (when (not (frame-parameter nil 'fullscreen))
				'fullboth)))
	((eq window-system 'mac)
	 (set-frame-parameter
	  nil 'fullscreen
	  (when (not (frame-parameter nil 'fullscreen)) 'fullscreen)))))
   #+end_src

   #+begin_src emacs-lisp :tangle yes
     (defun spacemacs/toggle-frame-fullscreen-non-native ()
       "Toggle full screen non-natively. Uses the `fullboth' frame paramerter
	rather than `fullscreen'. Useful to fullscreen on OSX w/o animations."
       (interactive)
       (modify-frame-parameters
	nil
	`((maximized
	   . ,(unless (memq (frame-parameter nil 'fullscreen) '(fullscreen fullboth))
		(frame-parameter nil 'fullscreen)))
	  (fullscreen
	   . ,(if (memq (frame-parameter nil 'fullscreen) '(fullscreen fullboth))
		  (if (eq (frame-parameter nil 'maximized) 'maximized)
		      'maximized)
		'fullboth)))))
   #+end_src

   #+begin_src emacs-lisp :tangle yes
     (defun spacemacs/switch-to-minibuffer-window ()
       "switch to minibuffer window (if active)"
       (interactive)
       (when (active-minibuffer-window)
	 (select-window (active-minibuffer-window))))
   #+end_src

   #+begin_src emacs-lisp :tangle yes
     (defun spacemacs/alternate-buffer (&optional window)
       "Switch back and forth between current and last buffer in the
     current window."
       (interactive)
       (let ((current-buffer (window-buffer window)))
	 ;; if no window is found in the windows history, `switch-to-buffer' will
	 ;; default to calling `other-buffer'.
	 (switch-to-buffer
	  (cl-find-if (lambda (buffer)
			(not (eq buffer current-buffer)))
		      (mapcar #'car (window-prev-buffers window))))))
   #+end_src

   #+begin_src emacs-lisp :tangle yes
     ;; from https://gist.github.com/3402786
     (defun spacemacs/toggle-maximize-buffer ()
       "Maximize buffer"
       (interactive)
       (if (and (= 1 (length (window-list)))
		(assoc ?_ register-alist))
	   (jump-to-register ?_)
	 (progn
	   (window-configuration-to-register ?_)
	   (delete-other-windows))))
   #+END_SRC
* vars
  #+BEGIN_SRC emacs-lisp :tangle yes
    (defvar my/evil-leader-key "SPC")
    (defvar my/emacs-leader-key "C-c s")
    (defvar my/evil-mode-leader-key ",")
    (defvar my/emacs-mode-leader-key "C-c ,")
    (defvar-local my/imenu-function 'imenu
      "Function called interactively by `my/imenu'")
  #+END_SRC

* keymaps
*** leader
   #+BEGIN_SRC emacs-lisp :tangle yes
     (bind-map my/base-map
       :keys (my/emacs-leader-key)
       :evil-keys (my/evil-leader-key)
       :evil-states (normal motion visual)
       :override-minor-modes t
       :bindings
       ("0" 'winum-select-window-0-or-10
	"1" 'winum-select-window-1
	"2" 'winum-select-window-2
	"3" 'winum-select-window-3
	"4" 'winum-select-window-4
	"5" 'winum-select-window-5
	"6" 'winum-select-window-6
	"7" 'winum-select-window-7
	"8" 'winum-select-window-8
	"9" 'winum-select-window-9
	"!" 'shell-command
	"v" 'er/expand-region
	";" 'evilnc-comment-operator
	":" 'evilnc-comment-and-copy-operator
	"SPC" 'counsel-M-x
	"TAB" 'spacemacs/alternate-buffer
	"u" 'universal-argument
	"d" 'dired
	"'" 'my/main-shell
	"/" 'my/buffer-shell))
     (bind-map my/mode-leader-map
       :evil-keys (my/evil-mode-leader-key)
       :evil-keys (my/emacs-mode-leader-key)
       :evil-states (normal motion visual)
       :override-minor-modes t)
   #+END_SRC
*** errors
    #+BEGIN_SRC emacs-lisp :tangle yes
      (bind-map my/errors-map
	    :keys ((my/make-emacs-prefix "e"))
	    :evil-keys ((my/make-evil-prefix "e"))
	    :evil-states (normal motion visual)
	    :override-mode-name buffer-keys
	    :prefix-cmd errors
	    :bindings
	    ("n" 'next-error
	    "p" 'previous-error))
 #+END_SRC

*** buffers
    #+BEGIN_SRC emacs-lisp :tangle yes
      (defhydra hydra-cycle-buffer (:foreign-keys nil :hint nil)
       "
      [_1_-_9_]:buffer-to [n]
      "
	("1" buffer-to-window-1)
	("2" buffer-to-window-2 )
	("3" buffer-to-window-3)
	("4" buffer-to-window-4)
	("5" buffer-to-window-5)
	("6" buffer-to-window-6)
	("7" buffer-to-window-7)
	("8" buffer-to-window-8)
	("9" buffer-to-window-9)
	("n" next-buffer "next")
	("p" previous-buffer "previous")
	("d" spacemacs/kill-this-buffer "kill")
	("q" nil))

       (defhydra hydra/prev-next-buffer (:foreign-keys nil)
	 ("n" next-buffer "next")
	 ("p" previous-buffer "previous"))

      (bind-map my/buffers-map
	:keys ((my/make-emacs-prefix "b"))
	:evil-keys ((my/make-evil-prefix "b"))
	:evil-states (normal motion visual)
	:prefix-cmd buffers
	:bindings
	("." 'spacemacs/buffer-transient-state/body
	 "1" 'buffer-to-window-1
	 "2" 'buffer-to-window-2
	 "3" 'buffer-to-window-3
	 "4" 'buffer-to-window-4
	 "5" 'buffer-to-window-5
	 "6" 'buffer-to-window-6
	 "7" 'buffer-to-window-7
	 "8" 'buffer-to-window-8
	 "9" 'buffer-to-window-9
	 "B" 'ibuffer
	 "N" 'spacemacs/new-empty-buffer
	 "P" 'spacemacs/copy-clipboard-to-whole-buffer
	 "R" 'spacemacs/safe-revert-buffer
	 "Y" 'spacemacs/copy-whole-buffer-to-clipboard
	 "b" 'switch-to-buffer
	 "d" 'spacemacs/kill-this-buffer
	 "e" 'spacemacs/safe-erase-buffer
	 "I" 'ibuffer
	 "m" 'spacemacs/kill-other-buffers
	 "n" 'hydra/prev-next-buffer/next-buffer
	 "p" 'hydra/prev-next-buffer/previous-buffer
	 "s" 'spacemacs/switch-to-scratch-buffer
	 "w" 'read-only-mode
	 "." 'hydra-cycle-buffer))
    #+END_SRC

*** Windows
    #+BEGIN_SRC emacs-lisp :tangle yes
       (defhydra hydra/window-navigation (:foreign-keys nil :exit nil)
	("h" evil-window-left "left")
	("j" evil-window-down "down")
	("k" evil-window-up "up")
	("l" evil-window-right "right")
	("s" split-window-below "Split below")
	("v" split-window-right "Split right")
	("d" spacemacs/delete-window "delete")
	("u" winner-undo "undo")
	("U" winner-redo "redo")
	("w" other-window "other window")
	("d" delete-window "delete")
	("o" other-frame "other frame")
	("D" delete-frame "delete")
	("q" nil "quit"))

      (defhydra hydra/other-frame (:foreign-keys nil) ("o" other-frame "repeat"))
      (defhydra hydra/other-window (:foreign-keys nil) ("w" other-window "repeat"))
      (defhydra hydra/winner-repeat (:foreign-keys nil) ("u" winner-undo "undo") ("U" winner-redo "redo"))

      (bind-map my/windows-map
	:keys ((my/make-emacs-prefix "w"))
	:evil-keys ((my/make-evil-prefix "w"))
	:evil-states (normal motion visual)
	:prefix-cmd windows
	:bindings
	("." 'hydra/window-navigation/body
	 "w" 'hydra/other-window/other-window
	 "o" 'hydra/other-frame/other-frame
	 "s" 'split-window-below
	 "S" 'split-window-below-and-focus
	 "v" 'split-window-right
	 "V" 'split-window-right-and-focus
	 "=" 'balance-windows
	 "S" 'split-window-below-and-focus
	 "V" 'split-window-right-and-focus
	 "u" 'hydra/winner-repeat/winner-undo
	 "U" 'hydra/winner-repeat/winner-redo
	 "2" 'spacemacs/layout-double-columns
	 "3" 'spacemacs/layout-triple-columns
	 "_" 'spacemacs/maximize-horizontally
	 "b" 'spacemacs/switch-to-minibuffer-window
	 "d" 'spacemacs/delete-window
	 "D" 'my/delete-frame-with-prompt
	 "m" 'spacemacs/toggle-maximize-buffer
	 "r" 'spacemacs/rotate-windows-forward
	 "=" 'balance-windows
	 "F" 'make-frame
	 "h" 'evil-window-left
	 "j" 'evil-window-down
	 "k" 'evil-window-up
	 "l" 'evil-window-right
	 "H" 'evil-window-move-far-left
	 "J" 'evil-window-move-very-bottom
	 "K" 'evil-window-move-very-top
	 "L" 'evil-window-move-far-right
	 "<S-down>" 'evil-window-move-very-bottom
	 "<S-left>" 'evil-window-move-far-left
	 "<S-right>" 'evil-window-move-far-right
	 "<S-up>" 'evil-window-move-very-top
	 "<down>" 'evil-window-down
	 "<left>" 'evil-window-left
	 "<right>" 'evil-window-right
	 "<up>" 'evil-window-up))
    #+END_SRC

*** Files
    #+BEGIN_SRC emacs-lisp :tangle yes
      (bind-map my/files-map
	:keys ((my/make-emacs-prefix "f"))
	:evil-keys ((my/make-evil-prefix "f"))
	:evil-states (normal motion visual)
	:prefix-cmd file
	:bindings
	("S" 'save-some-buffers
	 "b" 'counsel-bookmark
	 "g" 'rgrep
	 "j" 'dired-jump
	 "J" 'dired-jump-other-window
	 "f" 'find-file
	 "L" 'find-file-literally
	 "l" 'counsel-locate
	 "r" 'counsel-recentf
	 "s" 'save-buffer
	 "y" 'spacemacs/show-and-copy-buffer-filename
	 "vd" 'add-dir-local-variable
	 "vf" 'add-file-local-variable
	 "vp" 'add-file-local-variable-prop-line))
    #+END_SRC

*** compile/comment
   #+BEGIN_SRC emacs-lisp :tangle yes
     (require 'compile-plus)
     (bind-map my/compile-comment-map
       :keys ((my/make-emacs-prefix "c"))
       :evil-keys ((my/make-evil-prefix "c"))
       :evil-states (normal motion visual)
       :prefix-cmd compile-comment
       :bindings
       ("c" 'cp/compile
	"C" 'cp/compile-in-project-with-read
	"r" 'recompile
	"k" 'kill-compilation
	"l" 'my-comment-or-uncomment-region-or-line))
   #+END_SRC

*** Project
   #+BEGIN_SRC emacs-lisp :tangle yes
	  (bind-map my/projectile-map
	    :keys ((my/make-emacs-prefix "p"))
	    :evil-keys ((my/make-evil-prefix "p"))
	    :evil-states (normal motion visual)
	    :prefix-cmd projectile
	    :bindings
	    (
     ;;"SPC" 'counsel-projectile
	     ;; "!" 'projectile-run-shell-command-in-root
	     ;; "%" 'projectile-replace-regexp
	     ;; "&" 'projectile-run-async-shell-command-in-root
	     ;; "D" 'projectile-dired
	     ;; "F" 'projectile-find-file-dwim
	     ;; "G" 'projectile-regenerate-tags
	     ;; "I" 'projectile-invalidate-cache
	     ;; "R" 'projectile-replace
	     ;; "T" 'projectile-test-project
	     ;; "a" 'projectile-toggle-between-implementation-and-test
	     ;; "c" 'projectile-compile-project
	     ;; "e" 'projectile-edit-dir-locals
	     ;; "g" 'projectile-find-tag
	     ;; "k" 'projectile-kill-buffers
	     ;; "r" 'projectile-recentf
     ))
   #+END_SRC

*** search
    #+BEGIN_SRC emacs-lisp :tangle yes
      (bind-map my/search-map
	:keys ((my/make-emacs-prefix "s"))
	:evil-keys ((my/make-evil-prefix "s"))
	:evil-states (normal motion visual)
	:prefix-cmd search/symbol
	:bindings
	)
    #+END_SRC

*** git
    #+BEGIN_SRC emacs-lisp :tangle yes
      (bind-map my/git-map
	:keys ((my/make-emacs-prefix "g"))
	:evil-keys ((my/make-evil-prefix "g"))
	:evil-states (normal motion visual)
	:prefix-cmd git
	:bindings
	("f" 'my/git-file-map))
    #+end_src
**** git file
    #+begin_src emacs-lisp :tangle yes
      (bind-map my/git-file-map
	:keys ((my/make-emacs-prefix "g f"))
	:evil-keys ((my/make-evil-prefix "g f"))
	:evil-states (normal motion visual)
	:prefix-cmd git-file)
    #+END_SRC

*** Jump/join
    #+BEGIN_SRC emacs-lisp :tangle yes
      (bind-map my/jump-join-map
	:keys ((my/make-emacs-prefix "j"))
	:evil-keys ((my/make-evil-prefix "j"))
	:evil-states (normal motion visual)
	:prefix-cmd jump-join
	:bindings
	("D" 'dired-jump-other-window
	 "S" 'spacemacs/split-and-new-line
	 "d" 'dired-jump
	 "f" 'find-function
	 "i" 'my/imenu
	 "o" 'open-line
	 "q" 'dumb-jump-quick-look
	 "s" 'sp-split-sexp
	 "v" 'find-variable
))
    #+END_SRC

*** insert
    #+BEGIN_SRC emacs-lisp :tangle yes
      (bind-map my/insert-map
	:keys ((my/make-emacs-prefix "i"))
	:evil-keys ((my/make-evil-prefix "i"))
	:evil-states (normal motion visual)
	:prefix-cmd inserting)
    #+END_SRC

*** text
     #+BEGIN_SRC emacs-lisp :tangle yes
       (bind-map my/text-map
	 :keys ((my/make-emacs-prefix "x"))
	 :evil-keys ((my/make-evil-prefix "x"))
	 :evil-states (normal motion visual)
	 :prefix-cmd text
	 :bindings
	 ("TAB" 'indent-rigidly
	  "c" 'transpose-chars
	  "e" 'transpose-sexps
	  "l" 'transpose-lines
	  "p" 'transpose-paragraphs
	  "s" 'transpose-sentences
	  "w" 'transpose-words))
     #+end_src
**** TODO more from spacemacs to implement
     #+begin_src emacs-lisp :tangle no
       SPC x j c       set-justification-center
       SPC x j f       set-justification-full
       SPC x j l       set-justification-left
       SPC x j n       set-justification-none
       SPC x j r       set-justification-right
       (use-package string-inflection
       SPC x i -       string-inflection-kebab-case
       SPC x i C       string-inflection-camelcase
       SPC x i U       string-inflection-upcase
       SPC x i _       string-inflection-underscore
       SPC x i c       string-inflection-lower-camelcase
       SPC x i k       string-inflection-kebab-case
       SPC x i u       string-inflection-underscore)
	 :ensure t)
       (use-package google-translare
       SPC x g Q       google-translate-query-translate-reverse
       SPC x g T       google-translate-at-point-reverse
       SPC x g l       spacemacs/set-google-translate-languages
       SPC x g q       google-translate-query-translate
       SPC x g t       google-translate-at-point
	 :ensure t)

       SPC x a %       spacemacs/align-repeat-percent
       SPC x a &       spacemacs/align-repeat-ampersand
       SPC x a (       spacemacs/align-repeat-left-paren
       SPC x a )       spacemacs/align-repeat-right-paren
       SPC x a ,       spacemacs/align-repeat-comma
       SPC x a .       spacemacs/align-repeat-decimal
       SPC x a :       spacemacs/align-repeat-colon
       SPC x a ;       spacemacs/align-repeat-semicolon
       SPC x a =       spacemacs/align-repeat-equal
       SPC x a L       evil-lion-right
       SPC x a [       spacemacs/align-repeat-left-square-brace
       SPC x a \       spacemacs/align-repeat-backslash
       SPC x a ]       spacemacs/align-repeat-right-square-brace
       SPC x a a       align
       SPC x a c       align-current
       SPC x a l       evil-lion-left
       SPC x a m       spacemacs/align-repeat-math-oper
       SPC x a r       spacemacs/align-repeat
       SPC x a {       spacemacs/align-repeat-left-curly-brace
       SPC x a |       spacemacs/align-repeat-bar
       SPC x a }       spacemacs/align-repeat-right-curly-brace
       SPC x r '       rxt-convert-to-strings
       SPC x r /       rxt-explain
       SPC x r c       rxt-convert-syntax
       SPC x r e       Prefix Command
       SPC x r p       Prefix Command
       SPC x r t       rxt-toggle-elisp-rx
       SPC x r x       rxt-convert-to-rx

       SPC x r p '     rxt-pcre-to-strings
       SPC x r p /     rxt-explain-pcre
       SPC x r p e     rxt-pcre-to-elisp
       SPC x r p x     rxt-pcre-to-rx

       SPC x r e '     rxt-elisp-to-strings
       SPC x r e /     rxt-explain-elisp
       SPC x r e p     rxt-elisp-to-pcre
       SPC x r e t     rxt-toggle-elisp-rx
       SPC x r e x     rxt-elisp-to-rx



     #+END_SRC
***  registers/rings/resume
     #+BEGIN_SRC emacs-lisp :tangle yes
       (bind-map my/reg-ring-resume-map
	 :keys ((my/make-emacs-prefix "r"))
	 :evil-keys ((my/make-evil-prefix "r"))
	 :evil-states (normal motion visual)
	 :prefix-cmd regs-rings-resume)
    #+END_SRC
*** narrowing
    #+BEGIN_SRC emacs-lisp :tangle yes
      (bind-map my/narrow-map
	:keys ((my/make-emacs-prefix "n"))
	:evil-keys ((my/make-evil-prefix "n"))
	:evil-states (normal motion visual)
	:prefix-cmd regs-rings-resume
	:bindings
	("r" 'narrow-to-region
	 "f" 'narrow-to-defun
	 "p" 'narrow-to-page
	 "w" 'widen))
    #+END_SRC

*** toggle
    #+BEGIN_SRC emacs-lisp :tangle yes
      (bind-map my/toggle-map
	:keys ((my/make-emacs-prefix "t"))
	:evil-keys ((my/make-evil-prefix "n"))
	:evil-states (normal motion visual)
	:prefix-cmd regs-rings-resume
	:bindings)
    #+END_SRC
* global config
** evil
*** evil
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package evil
	:ensure t
	:init
	(setq evil-want-integration nil)
	(setq evil-want-keybinding nil)
	:config
	(evil-mode 1))
    #+END_SRC
*** evil-collection
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package evil-collection
	:after evil
	:ensure t
	:bind
	:config
	(evil-collection-init))
    #+END_SRC

*** evil-rsi
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package evil-rsi
	:ensure t
	:requires evil)
    #+END_SRC

*** evil-iedit-state
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package evil-iedit-state
	:ensure t
	:bind
	(:map my/search-map ("e" . evil-iedit-state/iedit-mode)))
    #+END_SRC
*** evil-escape
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package evil-escape
	:ensure t
	:requires evil
	:config
	(evil-escape-mode 1))
    #+END_SRC

*** evil-nerd-commenter
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package evil-nerd-commenter
	:ensure t
	:requires evil)
    #+END_SRC

*** evil-surround
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package evil-surround
	:ensure t
	    :init
	    (add-hook 'after-init-hook 'global-evil-surround-mode)
	    :requires evil)
    #+END_SRC

*** evil-exchange
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package evil-exchange
	:ensure t
	:requires evil
	:config
	(evil-exchange-cx-install))
    #+END_SRC

*** evil-unimpaired
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package evil-unimpaired
	:load-path "sumodules/evil-unimpaired"
	:requires evil
	:init
	(add-hook 'evil-mode-hook 'evil-unimpaired-mode))
    #+END_SRC

*** evil-rsi
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package evil-rsi
	:ensure t
	:requires evil
	:config (evil-rsi-mode 1))
    #+END_SRC

*** org-evil
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package org-evil
	 :ensure t
	 :requires evil)
    #+END_SRC
*** keybindings
  #+BEGIN_SRC emacs-lisp :tangle yes
  (evil-define-key '(insert normal visual) 'global-map (kbd "M-/")
    'hippie-expand)
  #+END_SRC
** projectile
*** projectile
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package projectile
	:init
	(add-hook 'after-init-hook 'projectile-mode)
	:config
	(setq projectile-enable-caching t)
	(setq projectile-completion-system 'ivy)
	:ensure t
	:after evil
	:bind
	(:map
	 my/projectile-map
	 ("!" . projectile-run-shell-command-in-root)
	 ("%" . projectile-replace-regexp)
	 ("&" . projectile-run-async-shell-command-in-root)
	 ("d" . projectile-dired)
	 ("D" . projectile-dired-other-window)
	 ("F" . projectile-find-file-dwim)
	 ("G" . projectile-regenerate-tags)
	 ("I" . projectile-invalidate-cache)
	 ("R" . projectile-replace)
	 ("T" . projectile-test-project)
	 ("a" . projectile-toggle-between-implementation-and-test)
	 ("c" . projectile-compile-project)
	 ("e" . projectile-edit-dir-locals)
	 ("g" . projectile-find-tag)
	 ("k" . projectile-kill-buffers)
	 ("v" . projectile-vc)
	 ("b" . projectile-switch-to-buffer)
	 ("B" . projectile-ibuffer)
	 ("f" . projectile-find-file)
	 ("p" . projectile-switch-project)
	 ("r" . projectile-recentf)))
    #+END_SRC
*** counsel-projectile
    #+begin_src emacs-lisp :tangle no
      (use-package counsel-projectile
	:ensure t
	:bind
	(:map
	 my/projectile-map
	 ("SPC" . counsel-projectile)
	 ("b" . counsel-projectile-switch-to-buffer)
	 ("f" . counsel-projectile-find-file)
	 ("d" . counsel-projectile-find-dir)
	 ("p" . counsel-projectile-switch-project)))

    #+end_src
*** ibuffer-projectile
    #+BEGIN_SRC emacs-lisp :tangle no
      (use-package ibuffer-projectile
	:ensure t
	:config
	(ibuffer-projectile-set-filter-groups))
    #+END_SRC
** ivy
*** ivy
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package ivy
	:ensure t
	:bind
	(:map ivy-minibuffer-map
	      (" " . ivy-alt-done)
	      ("C-j" . ivy-next-line)
	      ("C-k" . ivy-previous-line)
	      ("C-h" . 'ivy-backward-delete-char)
	      :map my/reg-ring-resume-map
	      ("m" . counsel-mark-ring)
	      ("y" . counsel-yank-pop)
	      ("l" . ivy-resume))
	:init
	(add-hook 'after-init-hook 'ivy-mode)
	:config
	(defvar spacemacs--counsel-commands
	  '(;; --line-number forces line numbers (disabled by default on windows)
	    ;; no --vimgrep because it adds column numbers that wgrep can't handle
	    ;; see https://github.com/syl20bnr/spacemacs/pull/8065
	    ("rg" . "rg --smart-case --no-heading --color never --line-number --max-columns 150 %s %S .")
	    ("ag" . "ag --nocolor --nogroup %s %S .")
	    ("pt" . "pt -e --nocolor --nogroup %s %S .")
	    ("ack" . "ack --nocolor --nogroup %s %S .")
	    ("grep" . "grep -nrP %s %S ."))
	  "An alist of search commands and their corresponding commands
      with options to run in the shell.")
	;; (evil-set-initial-state 'ivy-occur-grep-mode 'normal)
	;; (evil-make-overriding-map ivy-occur-mode-map 'normal)
	)
   #+END_SRC

*** ivy-yasnippet
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package ivy-yasnippet
	:ensure t
	:bind
	(:map my/insert-map ("y" . ivy-yasnippet)))
    #+END_SRC
*** ivy-hydra
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package ivy-hydra
       :ensure t
       :requires (ivy))
   #+END_SRC

*** counsel
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package counsel
       :ensure t
       :bind
       (:map my/search-map ("k" . counsel-ack) ("g"
	. counsel-git-grep) ("s" . swiper) ("K" . ack) ("k"
	. counsel-ack) ("g" . counsel-git-grep) ("G" . vc-git-grep)
	("a" . counsel-ag) ("A" . ag))
	:config
	(counsel-mode))
   #+END_SRC

** editing
*** iedit
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package iedit
       :ensure t)
   #+END_SRC
*** which-key
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package which-key
       :ensure t
       :init
       (add-hook 'after-init-hook 'which-key-mode))
   #+END_SRC

*** move-text
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package move-text
	:ensure t
	:init
	:bind
	(:map
	 evil-normal-state-map
	 ("[ e" . move-text-up)
	 ("] e" . move-text-down)))
    #+END_SRC

*** undo-tree
 #+BEGIN_SRC emacs-lisp :tangle yes
   (use-package undo-tree
     :ensure t)
 #+END_SRC

*** expand-region
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package expand-region
	:ensure t
	:config
	(setq expand-region-contract-fast-key "V"
	      expand-region-reset-fast-key "r"))
    #+END_SRC

*** evil-mc
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package evil-mc
	:ensure t
	:requires evil
	:bind
	(:map my/toggle-map
	      ("m" . evil-mc-mode))
	:config
	(evil-define-key '(normal visual) 'evil-mc-key-map
	  (kbd "g r N") 'evil-mc-skip-and-goto-next-cursor
	  (kbd "g r P") 'evil-mc-skip-and-goto-prev-cursor
	  (kbd "g r f") 'evil-mc-make-and-goto-first-cursor
	  (kbd "g r h") 'evil-mc-make-cursor-here
	  (kbd "g r j") 'evil-mc-make-cursor-move-next-line
	  (kbd "g r k") 'evil-mc-make-cursor-move-prev-line
	  (kbd "g r l") 'evil-mc-make-and-goto-last-cursor
	  (kbd "g r m") 'evil-mc-make-all-cursors
	  (kbd "g r n") 'evil-mc-skip-and-goto-next-match
	  (kbd "g r p") 'evil-mc-skip-and-goto-prev-match
	  (kbd "g r r") 'evil-mc-resume-cursors
	  (kbd "g r s") 'evil-mc-pause-cursors
	  (kbd "g r u") 'evil-mc-undo-all-cursors))
    #+END_SRC
** visual
   #+begin_src emacs-lisp :tangle no

   (use-package hl-anything
     :ensure t
     :config
     ) (use-package hl-indent
     :ensure t
     :config
     (add-hook 'prog-mode-hook 'hl-indent) ) (use-package hl-sentence
     :ensure t
     ) (use-package hl-todo
     :ensure t
     :config
     (global-hl-todo-mode) ) (
   #+END_SRC
** completion
*** yasnippet
 #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package yasnippet
	 :ensure t
	 :defer t
	 :init
	 (add-hook 'prog-mode-hook 'yas-minor-mode) (add-hook
	 'org-mode-hook 'yas-minor-mode)
	 :config
	 (add-to-list 'hippie-expand-try-functions-list
	 'yas-hippie-try-expand) (yas-reload-all)) (use-package
	 yasnippet-snippets
	 :ensure t
	 :requires yasnippet)
 #+END_SRC

*** flycheck
 #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package flycheck
       :ensure t
       :bind
	(:map my/toggle-map
	      ("f" . flycheck-mode))
       (:map my/errors-map
       ("." . spacemacs/error-transient-state/body)
	("S" . flycheck-set-checker-executable)
	("b" . flycheck-buffer)
	("c" . flycheck-clear)
	("h" . flycheck-describe-checker)
	("l" . my/flycheck-toggle-error-list)
	("s" . flycheck-select-checker)
	("v" . flycheck-verify-setup)
	("t" . flycheck-mode)
	("x" . flycheck-explain-error-at-point)
	("y" . flycheck-copy-errors-as-kill))
       :config
       (setq flycheck-idle-change-delay 2))
 #+END_SRC
**** funcs
     #+BEGIN_SRC emacs-lisp :tangle yes
       (defun my/flycheck-toggle-error-list () "Toggle flycheck's
	 error list window" (interactive) (-if-let (window
	 (flycheck-get-error-list-window)) (quit-window nil window)
	 (flycheck-list-errors)))
     #+END_SRC

*** company
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package company
	:ensure t
	:bind
	:config
	(setq company-idle-delay 0.5)
	(setq company-backends '((company-dabbrev-code
				  company-gtags
				  company-etags
				  company-keywords)
				 company-files
				 company-dabbrev)))
     #+END_SRC

** navigation
*** grep/ack/wgrep
 #+BEGIN_SRC emacs-lisp :tangle yes
   (use-package ag
     :ensure t)
 #+END_SRC


 #+BEGIN_SRC emacs-lisp :tangle yes
   (use-package ack
     :ensure t)
 #+END_SRC


 #+BEGIN_SRC emacs-lisp :tangle yes
   (use-package wgrep
     :ensure t)
 #+END_SRC


 #+BEGIN_SRC emacs-lisp :tangle yes
   (use-package wgrep-ack
     :ensure t)
 #+END_SRC


 #+BEGIN_SRC emacs-lisp :tangle yes
   (use-package wgrep-ag
     :ensure t)
 #+END_SRC

*** avy
 #+BEGIN_SRC emacs-lisp :tangle yes
   (use-package avy
	:ensure t
	:bind
	(:map my/jump-join-map
	      ("b" . pop-mark)
	      ("w" . avy-goto-word-or-subword-1)
	      ("j" . avy-goto-char)
	      ("J" . avy-goto-char-2)
	      ("T" . avy-goto-char-timer)
	      ("b" . avy-pop-mark)
	      ("l" . avy-goto-line))
	:init
	(setq avy-all-windows nil))
 #+END_SRC

*** link-hint
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package link-hint
	:ensure t
	:bind
	(:map
	 my/jump-join-map
	 ("h" . link-hint-open-link)))
    #+END_SRC
** windows and buffers
*** winum-mode
 #+BEGIN_SRC emacs-lisp :tangle yes
   (use-package winum
     :ensure t
     :config
     (winum-mode))
 #+END_SRC

** magit
*** magit
 #+BEGIN_SRC emacs-lisp :tangle yes
   (use-package magit
     :ensure t
     :bind
     (:map my/git-map
      ("s" . magit-status)
      ("A" . magit-cherry-pick-popup)
      ("b" . magit-branch-popup)
      ("b" . magit-bisect-popup)
      ("c" . magit-commit-popup)
      ("d" . magit-diff-popup)
      ("f" . magit-fetch-popup)
      ("F" . magit-pull-popup)
      ("l" . magit-log-popup)
      ("P" . magit-pushing-popup)
      ("r" . magit-rebase-popup)
      ("t" . magit-tag-popup)
      ("T" . magit-notes-popup)
      ("_" . magit-revert-popup)
      ("O" . magit-revert-popup)
      ("z" . magit-stash-popup)
      ("!" . magit-run-popup)
      :map my/git-file-map
      ("f" . magit-find-file)
      ("d" . magit-diff-buffer-file-popup)
      ("f" . magit-find-file)
      ("l" . magit-log-buffer-file)))
 #+END_SRC
*** evil-magit
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package evil-magit
	:after evil
	:ensure t
	:init
	:config
	(evil-magit-init))
    #+END_SRC
** hydra
   #+BEGIN_SRC emacs-lisp :tangle yes
  (use-package hydra
    :ensure t)
   #+END_SRC
** shell
*** vars
    #+BEGIN_SRC emacs-lisp :tangle yes
       (defcustom my-shell-program
		 "/bin/bash"
		 "Path to shell binary for shell opened by `my-shell-toggle-shell'"
		 :group 'my-shell)

       (defcustom my-shell-buffer-name-regex
		 "^\\*shell-.*\\*$"
		 "Regexp used to identify if the current window is a shell buffer"
		 :group 'my-shell)
    #+END_SRC

*** funcs
    #+BEGIN_SRC emacs-lisp :tangle yes
	(defun my-shell-toggle-shell(shell-buffer-name)
		  "Toggle a window and run program defined in `my-shell-program'
	If a buffer SHELL-BUFFER-NAME reuse, else start a new shell process"
		  (if (string-match "^\\*shell-.*\\*$" (buffer-name))
	      (delete-window)
	    (select-window (split-window-below))
	    (let ((buffer (get-buffer shell-buffer-name)))
	      (if buffer
		  (switch-to-buffer buffer)
		(shell my-shell-program)
		(rename-buffer shell-buffer-name)))))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp :tangle yes
	(defun my/main-shell ()
		  "Toggle the main shell"
		  (interactive)
		  (my-shell-toggle-shell "*shell-main*"))

	(defun my/buffer-shell ()
		  "Toggle a buffer local shell"
		  (interactive)
		  (my-shell-toggle-shell (concat "*shell-" (buffer-name) "*")))

	(provide 'my-shell)
	;;; my-shell.el ends here
    #+END_SRC

*** keys
    #+BEGIN_SRC emacs-lisp :tangle yes
      (bind-map-set-keys my/base-map
	"'" 'my/main-shell
	"/" 'my/buffer-shell)
    #+END_SRC
***  help-highlight
    #+BEGIN_SRC emacs-lisp :tangle yes
      (bind-map my/help-highlight-map
	:keys ((my/make-emacs-prefix "h"))
	:evil-keys ((my/make-evil-prefix "h"))
	:evil-states (normal motion visual)
	:prefix-cmd help-highlight)
    #+END_SRC
** ediff
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package ediff
      :config
     (setq ediff-merge-split-window-function 'split-window-horizontally)
     (setq ediff-split-window-function 'split-window-horizontally))
   #+END_SRC
** vlf
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package vlf
       :ensure t
       :config
       (evil-define-key '(normal visual) 'vlf-occur-mode-map
	 (kbd "C-m") 'vlf-occur-visit))
   #+END_SRC
** counsel-spotify
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package counsel-spotify
       :ensure t
       :bind
       (:map my/search-map
	("p a" . counsel-spotify-search-artist)
	("p A" . counsel-spotify-search-album)
	("p s" . counsel-spotify-search-track)
	("p n" . counsel-spotify-next)
	("p P" . counsel-spotify-previous)
	("p p" . counsel-spotify-toggle-play-pause)))
   #+END_SRC
** google-translate
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package google-translate
      :ensure t)
  #+END_SRC
** linum-relative
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package linum-relative
       :ensure t
       :config
       (add-hook 'prog-mode-hook 'linum-relative-mode))
   #+END_SRC
* plantuml-mode
	** plantuml-mode
   #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package plantuml-mode
       :ensure t
       :config
       (add-to-list 'auto-mode-alist '("\\.dox\\'" . plantuml-mode))
      (defun my/plantuml-preview-current-block ()
	(interactive)
	(plantuml-preview-current-block 16))

     (defun my/plantuml-preview-region()
	(interactive)
	(plantuml-preview-region 16))

     (defun my/plantuml-preview()
	(interactive)
	(plantuml-preview 16))

      (bind-map-for-major-mode plantuml-mode
	:keys (my/emacs-mode-leader-key)
	:evil-keys (my/evil-mode-leader-key)
	:evil-states (normal motion visual)
	:prefix rtags
	:bindings
	("p B" 'plantuml-preview-current-block
	 "p R" 'plantuml-preview-region
	 "p P" 'plantuml-preview
	 "p b" 'my/plantuml-preview-current-block
	 "p r" 'my/plantuml-preview-region
	 "p p" 'my/plantuml-preview)))
   #+END_SRC
* markdown-mode
  #+BEGIN_SRC emacs-lisp :tangle yes
  (use-package markdown-mode
    :ensure t
    :config)
  #+END_SRC
* org
** org
   #+BEGIN_SRC emacs-lisp :tangle yes
  (use-package org
    :ensure t
    :init
    (setq org-src-fontify-natively t)
    :config
      (defun my/org-mode-hooks ()
	(setq my/imenu-function #'counsel-org-goto))
      (add-hook 'org-mode-hook 'my/org-mode-hooks)
      (bind-map-for-major-mode org-mode
	:keys (my/emacs-mode-leader-key)
	:evil-keys (my/evil-mode-leader-key)
	:evil-states (normal motion visual)
	:override-minor-modes t
	:bindings
	("<tab>" 'org-indent-block
	 " RET" 'org-ctrl-c-ret
	 "#" 'org-update-statistics-cookies
	 "'" 'org-edit-special
	 "g" 'org-ctrl-c-star
	 "," 'org-ctrl-c-ctrl-c
	 "-" 'org-ctrl-c-minus
	 "A" 'org-attach
	 "H" 'org-shiftleft
	 "J" 'org-shiftdown
	 "K" 'org-shiftup
	 "L" 'org-shiftright
	 "a" 'org-agenda
	 "c" 'org-capture
	 "C-S-h" 'org-shiftcontrolleft
	 "C-S-j" 'org-shiftcontroldown
	 "C-S-k" 'org-shiftcontrolup
	 "C-S-l" 'org-shiftcontrolright
	 "x b" 'spacemacs/org-bold
	 "x c" 'spacemacs/org-code
	 "x i" 'spacemacs/org-italic
	 "x o" 'org-open-at-point
	 "x r" 'spacemacs/org-clear
	 "x s" 'spacemacs/org-strike-through
	 "x u" 'spacemacs/org-underline
	 "x v" 'spacemacs/org-verbatim
	 "i H" 'org-insert-heading-after-current
	 "i K" 'spacemacs/insert-keybinding-org
	 "i d" 'org-insert-drawer
	 "i e" 'org-set-effort
	 "i f" 'org-footnote-new
	 "i h" 'org-insert-heading
	 "i l" 'org-insert-link
	 "i n" 'org-add-note
	 "i p" 'org-set-property
	 "i s" 'org-insert-subheading
	 "i t" 'org-set-tags
	 "M-RET" 'org-meta-return
	 "b ." 'spacemacs/org-babel-transient-state/body
	 "b I" 'org-babel-view-src-block-info
	 "b Z" 'org-babel-switch-to-session-with-code
	 "b a" 'org-babel-sha1-hash
	 "b b" 'org-babel-execute-src-block
	 "b B" 'org-babel-execute-buffer
	 "b c" 'org-babel-check-src-block
	 "b d" 'org-babel-demarcate-block
	 "b e" 'org-babel-execute-maybe
	 "b f" 'org-babel-tangle-file
	 "b g" 'org-babel-goto-named-src-block
	 "b i" 'org-babel-lob-ingest
	 "b j" 'org-babel-insert-header-arg
	 "b l" 'org-babel-load-in-session
	 "b n" 'org-babel-next-src-block
	 "b o" 'org-babel-open-src-block-result
	 "b p" 'org-babel-previous-src-block
	 "b r" 'org-babel-goto-named-result
	 "b s" 'org-babel-execute-subtree
	 "b t" 'org-babel-tangle
	 "b u" 'org-babel-goto-src-block-head
	 "b v" 'org-babel-expand-src-block
	 "b x" 'org-babel-do-key-sequence-in-edit-buffer
	 "b z" 'org-babel-switch-to-session
	 "s A" 'org-archive-subtree
	 "s N" 'widen
	 "s S" 'org-sort
	 "s a" 'org-toggle-archive-tag
	 "s b" 'org-tree-to-indirect-buffer
	 "s h" 'org-promote-subtree
	 "s j" 'org-move-subtree-down
	 "s k" 'org-move-subtree-up
	 "s l" 'org-demote-subtree
	 "s n" 'org-narrow-to-subtree
	 "s r" 'org-refile
	 "s s" 'org-sparse-tree
	 "T T" 'org-todo
	 "T V" 'space-doc-mode
	 "T c" 'org-toggle-checkbox
	 "T e" 'org-toggle-pretty-entities
	 "T i" 'org-toggle-inline-images
	 "T l" 'org-toggle-link-display
	 "T t" 'org-show-todo-tree
	 "T x" 'org-toggle-latex-fragment
	 "f i" 'org-feed-goto-inbox
	 "f u" 'org-feed-update-all
	 "e e" 'org-export-dispatch
	 "e m" 'org-mime-org-buffer-htmlize
	 "d T" 'org-time-stamp-inactive
	 "d d" 'org-deadline
	 "d s" 'org-schedule
	 "d t" 'org-time-stamp
	 "C c" 'org-clock-cancel
	 "C i" 'org-clock-in
	 "C o" 'org-clock-out
	 "C p" 'org-pomodoro
	 "C r" 'org-resolve-clocks
	 "t E" 'org-table-export
	 "t H" 'org-table-move-column-left
	 "t I" 'org-table-import
	 "t J" 'org-table-move-row-down
	 "t K" 'org-table-move-row-up
	 "t L" 'org-table-move-column-right
	 "t N" 'org-table-create-with-table.el
	 "t a" 'org-table-align
	 "t b" 'org-table-blank-field
	 "t c" 'org-table-convert
	 "t e" 'org-table-eval-formula
	 "t h" 'org-table-previous-field
	 "t j" 'org-table-next-row
	 "t l" 'org-table-next-field
	 "t n" 'org-table-create
	 "t p" 'org-plot/gnuplot
	 "t r" 'org-table-recalculate
	 "t s" 'org-table-sort-lines
	 "t w" 'org-table-wrap-region
	 "i D s" 'org-download-screenshot
	 "i D y" 'org-download-yank
	 "t t f" 'org-table-toggle-formula-debugger
	 "t t o" 'org-table-toggle-coordinate-overlays
	 "t i H" 'org-table-hline-and-move
	 "t i c" 'org-table-insert-column
	 "t i h" 'org-table-insert-hline
	 "t i r" 'org-table-insert-row
	 "t d c" 'org-table-delete-column
	 "t d r" 'org-table-kill-row)))

   #+END_SRC
** org-projectile
   #+BEGIN_SRC emacs-lisp :tangle no
      (use-package org-projectile
	:ensure t
	:bind
	(:map
	 my/projectile-map
	 ("o" . org-projectile/goto-todos)))
   #+END_SRC
** company
   #+BEGIN_SRC emacs-lisp :tangle yes
      (defun my/org-company-setup ()
	     (add-to-list 'company-backends 'company-capf)
	     (company-mode))
	   (add-hook 'org-mode-hook 'my/org-company-setup)
   #+END_SRC
** keys
   #+BEGIN_SRC emacs-lisp :tangle no
      (bind-map-for-major-mode org-mode
		:keys (my/emacs-mode-leader-key)
		:evil-keys (my/evil-mode-leader-key)
		:evil-states (normal motion visual)
		:override-minor-modes t
		:bindings
		("<tab>" 'org-indent-block
	 " RET" 'org-ctrl-c-ret
	 "#" 'org-update-statistics-cookies
	 "'" 'org-edit-special
	 "g" 'org-ctrl-c-star
	 "," 'org-ctrl-c-ctrl-c
	 "-" 'org-ctrl-c-minus
	 "A" 'org-attach
	 "H" 'org-shiftleft
	 "J" 'org-shiftdown
	 "K" 'org-shiftup
	 "L" 'org-shiftright
	 "a" 'org-agenda
	 "c" 'org-capture
	 "C-S-h" 'org-shiftcontrolleft
	 "C-S-j" 'org-shiftcontroldown
	 "C-S-k" 'org-shiftcontrolup
	 "C-S-l" 'org-shiftcontrolright
	 "x b" 'spacemacs/org-bold
	 "x c" 'spacemacs/org-code
	 "x i" 'spacemacs/org-italic
	 "x o" 'org-open-at-point
	 "x r" 'spacemacs/org-clear
	 "x s" 'spacemacs/org-strike-through
	 "x u" 'spacemacs/org-underline
	 "x v" 'spacemacs/org-verbatim
	 "i h" 'org-insert-heading-after-current
	 "i H" 'org-insert-heading
	 "i K" 'spacemacs/insert-keybinding-org
	 "i d" 'org-insert-drawer
	 "i e" 'org-set-effort
	 "i f" 'org-footnote-new
	 "i l" 'org-insert-link
	 "i n" 'org-add-note
	 "i p" 'org-set-property
	 "i s" 'org-insert-subheading
	 "i t" 'org-set-tags
	 "M-RET" 'org-meta-return
	 "b ." 'spacemacs/org-babel-transient-state/body
	 "b I" 'org-babel-view-src-block-info
	 "b Z" 'org-babel-switch-to-session-with-code
	 "b a" 'org-babel-sha1-hash
	 "b b" 'org-babel-execute-src-block
	 "b B" 'org-babel-execute-buffer
	 "b c" 'org-babel-check-src-block
	 "b d" 'org-babel-demarcate-block
	 "b e" 'org-babel-execute-maybe
	 "b f" 'org-babel-tangle-file
	 "b g" 'org-babel-goto-named-src-block
	 "b i" 'org-babel-lob-ingest
	 "b j" 'org-babel-insert-header-arg
	 "b l" 'org-babel-load-in-session
	 "b n" 'org-babel-next-src-block
	 "b o" 'org-babel-open-src-block-result
	 "b p" 'org-babel-previous-src-block
	 "b r" 'org-babel-goto-named-result
	 "b s" 'org-babel-execute-subtree
	 "b t" 'org-babel-tangle
	 "b u" 'org-babel-goto-src-block-head
	 "b v" 'org-babel-expand-src-block
	 "b x" 'org-babel-do-key-sequence-in-edit-buffer
	 "b z" 'org-babel-switch-to-session
	 "s A" 'org-archive-subtree
	 "s N" 'widen
	 "s S" 'org-sort
	 "s a" 'org-toggle-archive-tag
	 "s b" 'org-tree-to-indirect-buffer
	 "s h" 'org-promote-subtree
	 "s j" 'org-move-subtree-down
	 "s k" 'org-move-subtree-up
	 "s l" 'org-demote-subtree
	 "s n" 'org-narrow-to-subtree
	 "s r" 'org-refile
	 "s s" 'org-sparse-tree
	 "T T" 'org-todo
	 "T V" 'space-doc-mode
	 "T c" 'org-toggle-checkbox
	 "T e" 'org-toggle-pretty-entities
	 "T i" 'org-toggle-inline-images
	 "T l" 'org-toggle-link-display
	 "T t" 'org-show-todo-tree
	 "T x" 'org-toggle-latex-fragment
	 "f i" 'org-feed-goto-inbox
	 "f u" 'org-feed-update-all
	 "e e" 'org-export-dispatch
	 "e m" 'org-mime-org-buffer-htmlize
	 "d T" 'org-time-stamp-inactive
	 "d d" 'org-deadline
	 "d s" 'org-schedule
	 "d t" 'org-time-stamp
	 "C c" 'org-clock-cancel
	 "C i" 'org-clock-in
	 "C o" 'org-clock-out
	 "C p" 'org-pomodoro
	 "C r" 'org-resolve-clocks
	 "t E" 'org-table-export
	 "t H" 'org-table-move-column-left
	 "t I" 'org-table-import
	 "t J" 'org-table-move-row-down
	 "t K" 'org-table-move-row-up
	 "t L" 'org-table-move-column-right
	 "t N" 'org-table-create-with-table.el
	 "t a" 'org-table-align
	 "t b" 'org-table-blank-field
	 "t c" 'org-table-convert
	 "t e" 'org-table-eval-formula
	 "t h" 'org-table-previous-field
	 "t j" 'org-table-next-row
	 "t l" 'org-table-next-field
	 "t n" 'org-table-create
	 "t p" 'org-plot/gnuplot
	 "t r" 'org-table-recalculate
	 "t s" 'org-table-sort-lines
	 "t w" 'org-table-wrap-region
	 "i D s" 'org-download-screenshot
	 "i D y" 'org-download-yank
	 "t t f" 'org-table-toggle-formula-debugger
	 "t t o" 'org-table-toggle-coordinate-overlays
	 "t i H" 'org-table-hline-and-move
	 "t i c" 'org-table-insert-column
	 "t i h" 'org-table-insert-hline
	 "t i r" 'org-table-insert-row
	 "t d c" 'org-table-delete-column
	 "t d r" 'org-table-kill-row))
   #+END_SRC

* prog-mode
** hooks
  #+BEGIN_SRC emacs-lisp :tangle yes
    (defun my/prog-mode-hooks ()
      (add-hook 'before-save-hook 'whitespace-cleanup))
    (add-hook 'prog-mode-hook 'my/prog-mode-hooks)
  #+END_SRC
** minior-modes
*** highlight-symbol
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package highlight-symbol
	:ensure t
	:bind
	(:map my/toggle-map
	      ("h" . evil-mc-mode))
	(:map
	 my/help-highlight-map
	 ("t" . highlight-symbol-mode)
	 ("s" . highlight-symbol)
	 ("n" . highlight-symbol-nav-mode)
	 ("o" . highlight-symbol-occur)
	 ("l" . highlight-symbol-list-all)
	 ("C" . highlight-symbol-remove-all)
	 ("c" . highlight-symbol-remove-all)
	 ("r" . highlight-symbol-query-replace))
	:config
	(setq highlight-symbol-color "white")
	(face-spec-set 'highlight-symbol-face
		       '((t :foreground "#eee8d5"))
		       'face-override-spec)
	(add-hook 'prog-mode-hook 'highlight-symbol-mode))
    #+end_src
*** indent-guide
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package indent-guide
	:ensure t
	:config
	(add-hook 'prog-mode-hook 'indent-guide-mode))
    #+END_SRC
*** highlight-parentheses
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package highlight-parentheses
	:ensure t
	:config
	(add-hook 'prog-mode-hook 'highlight-parentheses-mode))

    #+END_SRC
*** highlight-changes
    #+BEGIN_SRC emacs-lisp :tangle yes
      (defun my/setup-highlight-changes ()
	(highlight-changes-mode 1)
	(highlight-changes-visible-mode 0)

	(bind-map-set-keys my/help-highlight-map
	  "c" 'highlight-changes-visible-mode))

      (add-hook 'prog-mode-hook 'my/setup-highlight-changes)
    #+END_SRC
** emacs-lisp-mode
*** macrostep
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package macrostep
	:ensure t)
    #+END_SRC
*** flycheck
   #+BEGIN_SRC emacs-lisp :tangle yes
     (defun my/emacs-lisp-flycheck-setup()
       (require 'flycheck)
       (add-to-list 'flycheck-disabled-checkers 'emacs-lisp-checkdoc)
       (flycheck-mode))
     (add-hook 'emacs-lisp-mode-hook 'my/emacs-lisp-flycheck-setup)
   #+END_SRC
*** company
   #+BEGIN_SRC emacs-lisp :tangle yes
     (with-eval-after-load 'emacs-lisp-mode
      (add-to-list 'company-backends 'company-elisp))
   #+END_SRC
   #+BEGIN_SRC emacs-lisp :tangle yes
     (defun my-emacs-lisp-company-setup()
      (company-mode 1))
     (add-hook 'emacs-lisp-mode-hook 'my-emacs-lisp-company-setup)
   #+END_SRC
*** keys
**** Hydras
   #+BEGIN_SRC emacs-lisp :tangle yes
   #+END_SRC
**** Evaling
    #+BEGIN_SRC emacs-lisp :tangle yes
      (bind-map elisp-eval-map
	:keys ((my/make-emacs-mode-prefix "e"))
	:evil-keys ((my/make-evil-mode-prefix "e"))
	:major-modes (emacs-lisp-mode)
	:evil-state (normal motion visual)
	:prefix-cmd evaling
	:bindings
	("f" 'eval-defun
	 "$" 'lisp-state-eval-sexp-end-of-line
	 "b" 'eval-buffer
	 "e" 'eval-last-sexp
	 "f" 'eval-defun
	 "r" 'eval-region
	 ))
    #+end_src
**** Debugging
    #+begin_src emacs-lisp :tangle yes
      (bind-map elisp-debug-map
	:keys ((my/make-emacs-mode-prefix "d"))
	:evil-keys ((my/make-evil-mode-prefix "d"))
	:major-modes (emacs-lisp-mode)
	:evil-state (normal motion visual)
	:prefix-cmd debugging
	:bindings
	("F" 'spacemacs/edebug-instrument-defun-off
	 "f" 'edebug-defun
	 "t" 'spacemacs/elisp-toggle-debug-expr-and-eval-func
	 "m" 'macrostep-mode))
  #+END_SRC
** c++-mode
*** general
    Make .h files use c++-moode instead of c-m
    #+BEGIN_SRC emacs-lisp :tangle yes
      (defun my/setup-c++-mode ()
	(subword-mode))
      (add-hook 'c++-mode-hook 'my/setup-c++-mode)
      (add-to-list 'auto-mode-alist '("\\.h\\'" . c++-mode))
    #+END_SRC
    Add some paths for jumping between c and h files using 'ff-find-other-file
    #+BEGIN_SRC emacs-lisp :tangle yes
      (require 'find-file)
      (add-to-list  'cc-search-directories "../inc")
      (add-to-list 'cc-search-directories "../src")
    #+END_SRC
    Setup keybindings
    #+BEGIN_SRC emacs-lisp :tangle yes
      (bind-map-for-major-mode c++-mode
	:keys (my/emacs-mode-leader-key)
	:evil-keys (my/evil-mode-leader-key)
	:evil-states (normal motion visual)
	:prefix rtags
	:bindings
	("t o" 'cp/gtest-occur
	 "c t" 'cp/compile-gtest-suite-at-point
	 "c s" 'cp/compile-gtest-test-at-point
	 "c g" 'my/compile-and-gcov
	 "c c" 'cp/compile
	 "g a" 'ff-find-other-file))
    #+END_SRC
*** rtags
**** rtags
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package rtags
	:ensure t
	:init
	(defun my/setup-rtags-hooks ()
	  (setq my/imenu-function #'rtags-imenu))

	(add-hook 'c++-mode-hook 'my/setup-rtags-hooks)
	  (defhydra hydra/rtags-nav (:hint nil :color pink )
	    "
      Rtags Naviagion
      --------------------------------------------------------------------
      _g_:find symbol  _r_:references   _p_:previous  _f_:forward
      _i_:symbol-info  _n_:next         _b_:back      _q_:exit
      --------------------------------------------------------------------
      "
	    ("r"  rtags-find-references-at-point)
	    ("g"  rtags-find-symbol-at-point)
	    ("p"  rtags-previous-match)
	    ("f"  rtags-location-stack-forward)
	    ("b"  rtags-location-stack-back)
	    ("i"  rtags-symbol-info)
	    ("n"  rtags-next-match)
	    ("q"  nil :color blue))
	:config
	(add-to-list 'evil-overriding-maps '(rtags-dependency-tree-mode-map))
	(add-to-list 'evil-overriding-maps '(rtags-references-tree-mode-map))
	(setq rtags-display-result-backend 'ivy)
	(setq rtags-imenu-syntax-highlighting t)
	(setq rtags-autostart-diagnostics nil)
	(setq rtags-completions-enabled nil)
	(setq rtags-enable-unsaved-reparsing t)
	(bind-map-for-major-mode c++-mode
	  :keys (my/emacs-mode-leader-key)
	  :evil-keys (my/evil-mode-leader-key)
	  :evil-states (normal motion visual)
	  :prefix rtags
	  :bindings
	  ("g ." 'hydra/rtags-nav/body
	   "g g"  'rtags-find-symbol-at-point
	   "g G"  'rtags-find-symbol
	   "g r"  'rtags-find-references-at-point
	   "g R"  'rtags-find-references
	   "g F"  'rtags-find-file
	   "g v"  'rtags-find-virtuals-at-point
	   "g m"  'rtags-find-member-function
	   "g l"  'rtags-list-results
	   "g c"  'rtags-close-taglist
	   "g h"  'rtags-print-class-hierarchy
	   "g n"  'rtags-next-match
	   "g p"  'rtags-previous-match
	   "g f"  'rtags-location-stack-forward
	   "g b"    'rtags-location-stack-back
	   "g i"    'rtags-symbol-info
	   "g e f"  'rtags-fix-fixit-at-point
	   "g e F"  'rtags-fixit
	   "g e r"  'rtags-rename-symbol
	   "g e i"  'rtags-get-include-file-for-symbol
	   "g e m"  'rtags-make-member)))
	#+END_SRC
**** company-rtags
     #+BEGIN_SRC emacs-lisp :tangle yes
       (use-package company-rtags
	 :ensure t
	 :init
	 (defun my/setup-company-rtags ()
	   (add-to-list 'company-backends 'company-rtags))
	 :init
	 (evil-define-key '(normal) 'c++-mode-map
	   (kbd "C-SPC") 'company-rtags))
     #+END_SRC
**** flycheck-rtags
     #+BEGIN_SRC emacs-lisp :tangle no
      (use-package flycheck-rtags
	:ensure t
	:after (flycheck-mode rtags))
     #+END_SRC
**** ivy-rtags
     #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package ivy-rtags
	:ensure t
	:after (ivy rtags))
     #+END_SRC
*** flycheck
    #+BEGIN_SRC emacs-lisp :tangle yes
      (defun my/c++-flycheck-setup ()
	(flycheck-select-checker 'c/c++-clang)
	(flycheck-mode))

      (add-hook 'c++-mode-hook 'my/c++-flycheck-setup)
    #+END_SRC
*** company
    #+BEGIN_SRC emacs-lisp :tangle yes
      (defun my/c++-company-setup ()
	(company-mode))
      (add-hook 'c++-mode-hook 'my/c++-company-setup)
    #+END_SRC
*** google-c-style
    #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package google-c-style
	:ensure t
	:config
       (add-hook 'c++-mode-hook 'google-set-c-style))
    #+END_SRC

*** clang-format
    #+begin_src emacs-lisp :tangle yes
      (use-package clang-format :ensure t)

      (defun my/clang-format-if-file-exists ()
	(when (eq major-mode 'c++-mode)
	  (when (locate-dominating-file (buffer-file-name) ".clang-format")
	    (clang-format-buffer))))

      (add-hook 'before-save-hook 'my/clang-format-if-file-exists)
	    #+end_src
** python-mode
*** anaconda-mode
   #+BEGIN_SRC emacs-lisp :tangle yes
     (defun my-setup-python ()
       (eldoc-mode))

     (use-package anaconda-mode
       :init
       (add-hook 'python-mode-hook 'anaconda-mode)
       (add-hook 'python-mode-hook 'anaconda-eldoc-mode)
       :ensure t)
     (use-package company-anaconda
       :ensure t
       :init
       (defun my-setup-company-anaconda ()
	 (add-to-list 'company-backends 'company-anaconda)
	 (company-mode))
       (add-hook 'python-mode-hook 'my-setup-company-anaconda))

     (use-package pydoc :ensure t)
     (use-package counsel-pydoc :ensure t)
     (use-package importmagic :ensure t)
   #+END_SRC

* Todos
** DONE ivy resume bindings
   # ** TODO bindings for evil nerd commenter
** DONE fix ivy-occur
** TODO cursor color for state
** TODO modeline
** TODO smartparens
   spc j s sp split sexp
** TODO dumb-jump
** TODO register keybindings


** TODO snippets
** TODO h cc file keybindings
** DONE camelCaseMotion
** TODO clang-format hook
** TODO expand region reverse
** TODO ace-windows (hydra?)
